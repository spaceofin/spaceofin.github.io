<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/ec8169d84bc91095.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-cceda007551b34ac.js"/><script src="/_next/static/chunks/fd9d1056-42bca7a501e26700.js" async=""></script><script src="/_next/static/chunks/23-0400f1ada3445968.js" async=""></script><script src="/_next/static/chunks/main-app-e0d78c455d046f20.js" async=""></script><script src="/_next/static/chunks/231-6a7b6dfd7bcbf59a.js" async=""></script><script src="/_next/static/chunks/app/layout-c9173ec0898b2734.js" async=""></script><script src="/_next/static/chunks/app/commit-logs/page-d99efe98ee6ddcfc.js" async=""></script><title>Spaceofin Logs</title><meta name="description" content="A blog for study logs"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="256x256"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body><nav class="font-mono mx-16"><ul class="relative min-h-32 mt-14 mb-10 mx-2 sm:mx-12 lg:mx-14 flex flex-col md:flex-row md:space-x-12 lg:space-x-16 space-y-1 md:space-y-0 justify-center md:justify-start items-start sm:items-center md:items-center text-2xl md:text-3xl z-0 tracking-tight text-zinc-900 pl-4 sm:pl-0"><li><a href="/">Home</a></li><li><a href="/learning-logs">Learning Logs</a></li><li><a href="/commit-logs">Commit Logs</a></li></ul></nav><div class="flex justify-center py-10"><div class="page-background"><div class="flex flex-col sm:flex-row items-center sm:items-start justify-center h-full px-6 sm:px-0 sm:mr-5"><div class="flex w-full sm:max-w-[140px] flex-row sm:flex-col overflow-x-auto sm:overflow-x-visible mb-6 sm:mb-0 pb-2 sm:pb-0 pl-2 sm:pl-0"><nav class="font-thin text-lg mr-6"><ul class="flex flex-row sm:flex-col"><li class="flex w-[110px] justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md mx-2 my-1 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-sky-700 border-cyan-950">ALL</li><li class="flex w-[110px] justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md mx-2 my-1 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-sky-700 border-cyan-950"><span>24</span><span>-</span><span>10</span></li><li class="flex w-[110px] justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md mx-2 my-1 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-sky-700 border-cyan-950"><span>24</span><span>-</span><span>11</span></li><li class="flex w-[110px] justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md mx-2 my-1 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-sky-700 border-cyan-950"><span>24</span><span>-</span><span>12</span></li><li class="flex w-[110px] justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md mx-2 my-1 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-sky-700 border-cyan-950"><span>25</span><span>-</span><span>01</span></li><li class="flex w-[110px] justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md mx-2 my-1 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-sky-700 border-cyan-950"><span>25</span><span>-</span><span>02</span></li><li class="flex w-[110px] justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md mx-2 my-1 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-sky-700 border-cyan-950"><span>25</span><span>-</span><span>04</span></li></ul></nav></div><div class="flex overflow-y-auto w-full"><div class="flex flex-col overflow-y-auto gap-5 w-full"><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/250417_commit"><h3 class="text-lg font-normal my-2 mb-0">Page Router에서의 데이터 페칭 함수들 실습해보기(in Next.js)</h3><p class="flex justify-end">2025-04-17</p><div class="line-clamp-2">Page Router 방식에서 사용하는 다음의 데이터 페칭 함수들에 대한 실습을 진행합니다.

- getServerSideProps 
- getStaticProps 
- getStaticPaths 

getServerSideProps는 SSR에, getStaticProps와 getStaticPaths는 SSG에 사용됩니다.
SSR과의 비교를 위해 CSR의 경우도 함께 실습합니다.


 Client Side Rendering(with dynamic routes)

page router 방식에서 일반적인 Dynamic Routes 구현에 useRouter를 사용합니다.
아래는 클라이언트 사이드에서의 데이터 페칭을 위해 useEffect 내부에서 fetch 함수를 사용하고 가져온 데이터를 post 상태 변수에 할당하는 코드입니다.


// src/pages/posts-csr/[id].tsx
import { useRouter } from &quot;next/router&quot;;
import { useEffect, useState } from &quot;react&quot;;
import { Post } from &quot;../types/posts&quot;;

export default function PostDetail() {
  const router = useRouter();
  const { id } = router.query;

  const [post, setPost] = us</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">nextjs</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">page_router</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">getServerSideProps</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">getStaticProps</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">getStaticPaths</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/250207_commit"><h3 class="text-lg font-normal my-2 mb-0">ts 파일 실행하기</h3><p class="flex justify-end">2025-02-07</p><div class="line-clamp-2">로컬 데이터베이스인 SQLite를 이용하다 보면 가끔 db 내의 데이터를 모두 삭제해야 할 필요가 있을 때가 있습니다.

이럴 때 db 내 데이터를 삭제하는 코드를 담은 .ts 파일을 생성하여 실행하는 방식으로 하는데, 새로 생성한 nextjs 프로젝트에서 .ts 파일을 실행하려 하자 여러 가지 문제가 발생했습니다.

아래는 문제가 된 파일입니다.


// deleteALLData.ts
import { PrismaClient } from &quot;@prisma/client&quot;;

const prisma = new PrismaClient();

async function deleteAllData() {
  try {
    await prisma.memo.deleteMany();
    console.log(&quot;All memo data deleted&quot;);
  } catch (error) {
    console.error(&quot;Error deleting data: &quot;, error);
  }
}

deleteAllData();



 ts 확장자 파일 실행하기와 Trouble 발생

node 명령어로는 .js 확장자 파일만 실행이 가능합니다. .ts 확장자 파일을 실행하기 위해서는 ts-node 패키지의 추가 설치가 필요합니다.


npm install ts-node --save-dev


ts-node 설치 후 파일 실행 명령어를 입력합니다.


n</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">typescript</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">node</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">ts-node</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">tsx</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">module</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">commonjs</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">import</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">require</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">ts</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/250206_commit"><h3 class="text-lg font-normal my-2 mb-0">prisma schema model 수정하기</h3><p class="flex justify-end">2025-02-06</p><div class="line-clamp-2">model 수정하기

기존 Memo model에는 isPublic 이라는 boolean 타입의 field가 포함되어 있었습니다.

초기 memo-board 앱에는 Group model 없었고 메모는 public/private 두 가지 타입만 존재했기에 isPublic 필드로 데이터를 표현하기에 충분했습니다.

하지만 Group model을 추가하고 난 후에는 해당 그룹에 속하는 그룹원들에게만 보이는 메모 타입이 필요해졌습니다. isPublic  필드 대신 public/private/group으로 구분하는 새로운 필드를 사용하기로 합니다.

PUBLIC/PRIVATE/GROUP 으로 정의된 Visibility 라는 enum 타입을 추가하고 Memo model에 isPublic field 대신 Visibility 타입의 visibility 필드를 추가합니다. 기본값은 PRIVATE으로 주었습니다.


 (수정 전 Memo model)


 (수정 후 Memo model)




 바뀐 model에 맞도록 코드 수정하기

memo.isPublic의 boolean 값으로 조건 검사를 하던 코드는 memo.visibility === Visibility.Public으로 수정합니다.

form을 이용해 memo를 create하던 코드는 form에 visibility 항목을 추가하고, memo를 edit하던 코드에도 isPublic 을 visibi</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">prisma</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">model</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">db</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/250106_commit"><h3 class="text-lg font-normal my-2 mb-0">리액트 JS 프로젝트(animal-friends) 리팩토링</h3><p class="flex justify-end">2025-01-06</p><div class="line-clamp-2">프로젝트 주소

https://animal-friends-ts.netlify.app


animal freidns 애플리케이션은 React 학습 후 처음 만든 포트폴리오 프로젝트입니다.

CRA로 생성한 React JS 프로젝트이며 기능이 작동하는 것에 주안점을 두고 구축하다 보니 내부 구조가 좋지 못했습니다. 애플리케이션의 더 매끄러운 작동을 위해 리팩토링을 하기로 합니다.

리팩토링 과정은 아래의 단계로 진행하였습니다.


1. Vite 프로젝트 생성 및 환경 변수 수정
2. javascript 파일들을 typescript 파일로 변환(일단 작동하게만)
3. UserContext과 useAuth hook 코드 정리



 1. Vite 프로젝트 생성 및 환경 변수 수정

기존의 프로젝트는 CRA으로 만든 프로젝트였으나 리팩토링 프로젝트는 Vite를 사용하였습니다.

REACT_APP_으로 시작하던 환경 변수들을 VITE_로 시작하도록, process.env. 접두어를 붙여 사용하던 환경 변수들은 import.meta.env. 접두어를 사용하도록 수정하였습니다.


 2. javascript 파일들을 typescript 파일로 변환

 자바스크립트 파일을 타입스크립트 파일로 변경하기

프로젝트 내 js, jsx 파일들의 확장자를 ts, tsx 확장자로 변경하였으며, 타입스크립트 파일들 내에 필요한 타입들을 추가해주었습니다.

파일 </div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">react</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">CRA</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">vite</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">refactoring</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/241205_commit"><h3 class="text-lg font-normal my-2 mb-0">memo editing 기능 구현하기</h3><p class="flex justify-end">2024-12-05</p><div class="line-clamp-2">생성된 메모의 title이나 description을 수정 후 다시 db에 저장하는 기능을 구현하려고 합니다.


 Dynamic routes를 이용한 memo edit 페이지 생성

각 메모별 별도의 edit 페이지를 가지게 하기 위해 dynamic route 를 이용합니다.
메모 수정 작업은 /memos/[id]/edit 페이지에서 수행되며, [id] 부분 즉, dynamic segments 부분은 build time에 채워넣어 집니다.

params prop은 Promise 입니다. 따라서 async/await 를 사용해야 합니다.


// memo-board/src/app/memos/[id]/edit/page.tsx

import { db } from &quot;@/app/db&quot;;
import { notFound } from &quot;next/navigation&quot;;
import MemoEditSection from &quot;./memo-edit-section&quot;;

export default async function MemoEdit({
  params,
}: {
  params: Promise&lt;{ id: string }&gt;;
}) {
  const { id } = await params;
  const memo = await db.memo.findFirst({
    where: { id: parseInt(id) },
  });
  if (!memo) </div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">nextjs</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">react</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">dynamic_routes</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">generateStaticParams</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">server_action</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/241201_commit"><h3 class="text-lg font-normal my-2 mb-0">memo creation 기능 구현하기</h3><p class="flex justify-end">2024-12-01</p><div class="line-clamp-2">새로운 메모 생성을 위해 필요한 것들

메모 생성 페이지에서 메모의 제목과 내용을 입력하고 Create 버튼을 클릭하면 새로운 메모가 생성되게 하려고 합니다.

prisma.schema에서 Memo model을 살펴봅니다.
Memo model은 id, title, content 필드로 구성되어 있습니다.


// prisma.schema
...
model Memo {
  id    Int    @id @default(autoincrement())
  title String
  content  String
}
...


메모 생성 기능 구현에 필요한 구체적인 것들을 정리합니다.

- title, content 항목을 포함하는 클라이언트 컴포넌트의 form
- form 제출 시, form data를 받아서 필요한 로직을 수행하는 서버 컴포넌트 함수
	- form validation
	- create 메서드 호출을 통한 데이터 생성



 메모 생성 기능 구현하기

 생성할 memo data의 form 제출 구현(client component)

form 제출에는 useActionState 리액트 훅을 사용합니다.
형식은 아래와 같습니다.


const [state, formAction, isPending] = useActionState(fn, initialState, permalink?);


폼의 제출 과정 중 발생하는 에러를 mess</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">nextjs</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">useActionState</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">form</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">react</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">prisma</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/241128_commit"><h3 class="text-lg font-normal my-2 mb-0">블로그 포스트 내 이미지 변환 로직 변경하기(with supabase)</h3><p class="flex justify-end">2024-11-28</p><div class="line-clamp-2">Trouble

기존의 이미지 텍스트를 image url로 변환하는 로직은 단순히 index 의 숫자를 하나씩 증가 시켜 가면서 매칭시켰기 때문에 반드시 포스트 내 이미지의 순서와 supabase storage로부터 가져온 이미지 파일의 순서가 일치해야만 정상적으로 작동하는 로직이었습니다.

게다가 supabase의 storage로부터 파일명 리스트를 가져오는 .list 함수의 sortBy 옵션은 기본값을 제공하고 있지 않은데 기존의 코드는 sortBy 옵션을 지정해 두지도 않은 상태였습니다. 그럼에도 기본적으로 supabase storage 내에서의 파일 정렬이 파일의 Name 기준 오름차순으로 되어 있어 우연히 문제가 발생하지 않았던 것으로 보입니다.

이미지 url 변환을 단순 index에 의존하지 않고 이미지 파일명과 분명하게 매칭되는 경우에만 해당 파일명을 이미지 url로 변환하도록 합니다.

또한, 블로그 포스트에 쓰이는 이미지의 양이 방대하지 않은데 각각의 폴더로 별도로 저장하는 로직이 불필요하다는 생각이 들어 기존의 post title에 따라 각각 별도의 폴더에 이미지를 저장하던 방식에서 하나의 images 폴더에 해당 페이지의 전체 포스트 이미지들을 저장하는 방식으로 수정하기로 하였습니다.

 Trouble 해결

 수정 전 코드


const { data: imageFileList, error } = await su</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">supabase</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/241126_commit"><h3 class="text-lg font-normal my-2 mb-0">useSWR fallbackData 옵션 관련 이슈 처리</h3><p class="flex justify-end">2024-11-26</p><div class="line-clamp-2">Trouble

useSWR에서 fallbackData 옵션 사용 시, revalidateIfStale 옵션을 false로 두면 limit 값을 변경해도 refetch가 일어나지 않는 문제가 발생하였습니다.


const { data, isLoading, error } = useSWR([page, limit, order],{
	fallbackData: initialTodos,
	revalidateIfStale: false,
});


revalidateIfStale을 false 로 둔 이유는 default 값인 true로 둘 경우 limit 값을 변경할 때마다 이전에 이미 불러온 데이터임에도 캐시 데이터를 사용하지 않고 refetch가 일어났기 때문입니다.

 Trouble 원인


https://github.com/vercel/swr/issues/284


위의 사이트를 참고하여 문제의 원인을 파악할 수 있었습니다. 

fallbackData는 각 key 값에 대해 초기값으로 할당되는 데이터입니다. 
즉, limit을 변경하여 key 값이 변경되면 해당 key에 다시 fallbackData가 할당되며 revalidateIfStale이 false로 설정되어 있으므로 refetch가 일어나지 않고, limit 값이 또 바뀌어도 해당 키에 다시 fallbackData가 할당될 뿐이므로 데이터 리페칭이 일어나지 않는 것이었습니다. 

 T</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">swr</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">fallbackData</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">useSWR</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/241118_commit"><h3 class="text-lg font-normal my-2 mb-0">Github blog 배포 에러 처리하기</h3><p class="flex justify-end">2024-11-18</p><div class="line-clamp-2">Trouble: 배포 에러

github pages를 이용한 github 블로그 배포 중 여러가지 에러가 발생하였습니다.

 배포 에러 1. 타입 에러



generateStaticParams가 반환하는 값의 타입이 { slug: string }[]이어야 하는데, 반환되는 값에 undefined가 포함될 가능성이 있기 때문에 발생하는 오류입니다.

 수정 전 코드

export async function generateStaticParams() {
  const slugs = await getPostTitles({ page: &quot;commit-logs&quot; });

  return slugs?.map((slug) =&gt; ({ slug }));
}


 수정 후 코드

export async function generateStaticParams() {
  const slugs = await getPostTitles({ page: &quot;commit-logs&quot; });

  return (slugs ?? []).map((slug) =&gt; ({ slug }));
}



 배포 에러 2. React Hook 함수의 부적절한 사용



 배포 에러 2-1.

useMDXComponents 라는 React Hook이 getMetadata라는 함수 내에서 호출되고 있는 것이 문제입니다. useMDXComponents 함수의 함수명을 getMDXComponent</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">github_blog</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">deploy</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">github_pages</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/241115_commit"><h3 class="text-lg font-normal my-2 mb-0">Cart feature 리팩토링</h3><p class="flex justify-end">2024-11-15</p><div class="line-clamp-2">리팩토링1: totalValue 계산을 slice 파일로 옮기기

 코드 수정 전


// Cart.tsx
...
export const Cart = () =&gt; {
  const dispatch = useAppDispatch();
  const { items: itemList, searchTerm } = useAppSelector(selectCart);

  const [itemName, setItemName] = useState&lt;string&gt;(&quot;&quot;);
  const [itemValue, setItemValue] = useState&lt;number&gt;(0);
  const [totalValue, setTotalValue] = useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    setTotalValue(itemList.reduce((acc, item) =&gt; acc + item.value, 0));
  }, [itemList]);
  ...
}



// cartSlice.ts
...
export const selectCart = ({ cart: { searchTerm, items } }: RootState) =&gt; {
  const filteredItems = items.filter((item) =&gt;
    item.name.toLocaleLowerCase().includes(searchTerm.toLowerCa</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">react-redux</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">createSelector</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/241105_commit"><h3 class="text-lg font-normal my-2 mb-0">tailwindcss 동적 클래스 이름(dynamic class name) 사용하기</h3><p class="flex justify-end">2024-11-05</p><div class="line-clamp-2">Trouble: tailwindcss에서 템플릿 리터럴(template literal) 사용이 안 돼요

tailwindcss에서 당연히 가능할 것 같았던 문법이 제대로 동작하지 않습니다. 아래와 같은 템플릿 리터럴 부분입니다.


const bgColor = bg-${color}-300;


문제가 되는 부분의 코드는 아래와 같습니다.


{dayTodos.map((todo, index) =&gt; {
	...
	const topClass = top-${4 + todo.index * 4};
	const bgColor = bg-${todo.color}-300;
	return (
		&lt;div
		  key={index}
		  className={absolute ${topClass} left-0 w-full h-4 z-0 ${bgColor}}&gt;&lt;/div&gt;
	);
	})}


공식 문서를 찾아보면 Don’t use props to build class names dynamically라고 안내하고 있습니다.

class names을 동적으로 사용하면 안되며 항상 완전한 class names를 사용하라고 합니다.


// error code
&lt;div class=&quot;text-{{ error ? &#x27;red&#x27; : &#x27;green&#x27; }}-600&quot;&gt;&lt;/div&gt;



// error code
function Button({ color, children }) {
 </div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">tailwindcss</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">dynamic_class_name</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/241102-241103_commit"><h3 class="text-lg font-normal my-2 mb-0">Form update 하기(with RHF)</h3><p class="flex justify-end">2024-11-03</p><div class="line-clamp-2">Q. Form을 수정하려면 어떻게 해야 할까요?


 저장된 값 띄우기

todo card의 edit 버튼을 클릭하면 저장된 값들이 form에 떠야합니다.

 시도 1. setValue 이용하기

getTodoById 함수를 이용하여 DB로부터 해당 todo 에 대한 정보를 가져오고 setValue를 이용하여 값을 하나하나 입력해주는 방식입니다.


  useEffect(() =&gt; {
    const fetchTodoById = async () =&gt; {
      if (todoIdToUpdate) {
        todoToUpdate = await getTodoById(todoIdToUpdate);
        const {
          task,
          category,
          priority,
          startTimeStamp,
          endTimeStamp,
          memo,
          status,
        } = todoToUpdate;
        const [startDate, startTime] = startTimeStamp.slice(0, -4).split(&quot;T&quot;);
        const [endDate, endTime] = endTimeStamp.slice(0, -4).split(&quot;T&quot;);

        const dateOnly</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">react-hook-form</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">RHF</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/241009_commit"><h3 class="text-lg font-normal my-2 mb-0">CompileMDX로 frontmatter 데이터 분리하기</h3><p class="flex justify-end">2024-10-09</p><div class="line-clamp-2">Trouble: CompileMDX 함수의 리턴 타입 에러


getMetadata 함수에 리턴 타입 지정을 하지 않았더니 frontmatter 데이터의 title을 출력했을 때 맞는 문자열들이 화면에 출력되기는 하지만 코드 자체에 빨간색으로 에러 표시가 생겼습니다.


async function getMetadata({ source }: { source: string }) {
  return await compileMDX({
    source,
    options: {
      parseFrontmatter: true,
    },
  });
}




그래서 mdx post들의 타입 지정을 하고 getMetadata 함수에 리턴 타입을 할당해 주었습니다.


export type MDXPost = {
  content: string;
  frontmatter: { title: string; date: string; tags: string[] };
};



async function getMetadata({
  source,
}: {
  source: string;
}): Promise&lt;CompileMDXResult&lt;MDXPost&gt;&gt; {
  return await compileMDX({
    source,
    options: {
      parseFrontmatter: true,
    },
  });
}


그런데 </div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">nextjs</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">typescript</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/241008_commit"><h3 class="text-lg font-normal my-2 mb-0">마크다운 인라인 코드(inline code)의 백틱 표시 제거하기</h3><p class="flex justify-end">2024-10-08</p><div class="line-clamp-2">Trouble: 왜 자꾸 백틱(\)이 화면에 나타날까요?



mdx 파일에서는 inline code로 감싸져 효과만 주던 백틱이 MDXRemote 로 렌더링 된 후에는 백틱까지 화면에 나타납니다.

&lt;MDXRemote /&gt;는 MDX 콘텐츠를 HTML로 변환하여 화면에 렌더링되도록 해주는 함수입니다.

삼중 백틱(\\\\)의 경우 &lt;pre&gt;&lt;code&gt;...&lt;/code&gt;&lt;/pre&gt;로 변환되지만 와 백틱 하나(\)의 경우 &lt;code&gt;...&lt;/code&gt;로 변환됩니다.

그런데 화면에 렌더링 시, 삼중 백틱은 나타나지 않지만 백틱은 나타납니다. 



보기에 좋지가 않기에 인라인 코드 좌우의 단일 백틱 제거가 필요합니다.



 Trouble 원인 찾기

 가설1. MDXRemote가 백틱을 포함한 html element 로 변환해 주는 걸까요?

이유는 알 수 없지만 MDXRemote 가 백틱을 단순히 &lt;code&gt;...&lt;/code&gt;가 아닌 &lt;code&gt;\...\&lt;/code&gt;로 변환해주는 문제인지 테스트를 해봅니다.

mdx-components.tsx 파일 내 code 부분에 정규표현식을 이용하여 백틱 문자 제거 후 렌더링하여 봅니다.

export function useMDXComponents(components: MDXComponents): MDXComponents {

  return {
    ...,
	code: ({ children</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">nextjs</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">markdown</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">html</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">prose</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/commit-logs/241006-241007_commit"><h3 class="text-lg font-normal my-2 mb-0">블로그 포스트 내 이미지 띄우기(with supabase)</h3><p class="flex justify-end">2024-10-07</p><div class="line-clamp-2">getMDXPosts는 posts 버킷의 mdx 폴더의 파일 리스트를 가져와 해당 파일들을 다운로드 후 텍스트 변환하고 string[] 타입으로 반환하는 함수입니다.
 
javascript
export async function getMDXPosts() {
  const { data: fileList, error } = await supabase.storage
    .from(&quot;posts&quot;)
    .list(&quot;mdx&quot;);

  if (error) {
    console.error(&quot;Error occurred while loading the file list:&quot;, error.message);
    return [];
  }

  const posts = [];

  for (const file of fileList) {
    const { data, error } = await supabase.storage
      .from(&quot;posts&quot;)
      .download(mdx/${file.name});

    if (error) {
      console.error(Error downloading file ${file.name}:, error.message);
      continue;
    }
    const text = await data.text();
    posts.push(text);
  }

  ret</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">supabase</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">nextjs</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">react</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">regular_expression</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap ">sql</span></div></a></div></div></div></div></div><script src="/_next/static/chunks/webpack-cceda007551b34ac.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/ec8169d84bc91095.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n6:I[1343,[],\"\"]\n7:I[5767,[\"231\",\"static/chunks/231-6a7b6dfd7bcbf59a.js\",\"185\",\"static/chunks/app/layout-c9173ec0898b2734.js\"],\"PostProvider\",1]\n8:I[231,[\"231\",\"static/chunks/231-6a7b6dfd7bcbf59a.js\",\"185\",\"static/chunks/app/layout-c9173ec0898b2734.js\"],\"\"]\na:I[6130,[],\"\"]\nb:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L2\",null,{\"buildId\":\"zXZxd2y7yPD2GEWj3kSkd\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"commit-logs\"],\"initialTree\":[\"\",{\"children\":[\"commit-logs\",{\"children\":[\"__PAGE__\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"commit-logs\",{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"commit-logs\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ec8169d84bc91095.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"$L7\",null,{\"children\":[\"$\",\"body\",null,{\"children\":[[\"$\",\"nav\",null,{\"className\":\"font-mono mx-16\",\"children\":[\"$\",\"ul\",null,{\"className\":\"relative min-h-32 mt-14 mb-10 mx-2 sm:mx-12 lg:mx-14 flex flex-col md:flex-row md:space-x-12 lg:space-x-16 space-y-1 md:space-y-0 justify-center md:justify-start items-start sm:items-center md:items-center text-2xl md:text-3xl z-0 tracking-tight text-zinc-900 pl-4 sm:pl-0\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"$L8\",null,{\"href\":\"/\",\"children\":\"Home\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"$L8\",null,{\"href\":\"/learning-logs\",\"children\":\"Learning Logs\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"$L8\",null,{\"href\":\"/commit-logs\",\"children\":\"Commit Logs\"}]}]]}]}],[\"$\",\"div\",null,{\"className\":\"flex justify-center py-10\",\"children\":[\"$\",\"div\",null,{\"className\":\"page-background\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]}]]}]}]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$L9\"],\"globalErrorComponent\":\"$a\",\"missingSlots\":\"$Wb\"}]\n"])</script><script>self.__next_f.push([1,"9:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Spaceofin Logs\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"A blog for study logs\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"256x256\"}]]\n3:null\n"])</script><script>self.__next_f.push([1,"c:I[9077,[\"231\",\"static/chunks/231-6a7b6dfd7bcbf59a.js\",\"521\",\"static/chunks/app/commit-logs/page-d99efe98ee6ddcfc.js\"],\"DateFilterNav\",1]\nd:I[9859,[\"231\",\"static/chunks/231-6a7b6dfd7bcbf59a.js\",\"521\",\"static/chunks/app/commit-logs/page-d99efe98ee6ddcfc.js\"],\"default\",1]\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col sm:flex-row items-center sm:items-start justify-center h-full px-6 sm:px-0 sm:mr-5\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex w-full sm:max-w-[140px] flex-row sm:flex-col overflow-x-auto sm:overflow-x-visible mb-6 sm:mb-0 pb-2 sm:pb-0 pl-2 sm:pl-0\",\"children\":[\"$\",\"$Lc\",null,{\"postDates\":[\"2025-04-17\",\"2025-02-07\",\"2025-02-06\",\"2025-01-06\",\"2024-12-05\",\"2024-12-01\",\"2024-11-28\",\"2024-11-26\",\"2024-11-18\",\"2024-11-15\",\"2024-11-05\",\"2024-11-03\",\"2024-10-09\",\"2024-10-08\",\"2024-10-07\"],\"className\":\"bg-sky-700 border-cyan-950\"}]}],[\"$\",\"div\",null,{\"className\":\"flex overflow-y-auto w-full\",\"children\":[\"$\",\"$Ld\",null,{\"postSummaries\":[{\"frontmatter\":{\"title\":\"Page Router에서의 데이터 페칭 함수들 실습해보기(in Next.js)\",\"created_at\":\"2025-04-17\",\"updated_at\":\"2025-04-17\",\"tags\":[\"nextjs\",\"page_router\",\"getServerSideProps\",\"getStaticProps\",\"getStaticPaths\"]},\"preview\":\"Page Router 방식에서 사용하는 다음의 데이터 페칭 함수들에 대한 실습을 진행합니다.\\n\\n- getServerSideProps \\n- getStaticProps \\n- getStaticPaths \\n\\ngetServerSideProps는 SSR에, getStaticProps와 getStaticPaths는 SSG에 사용됩니다.\\nSSR과의 비교를 위해 CSR의 경우도 함께 실습합니다.\\n\\n\\n Client Side Rendering(with dynamic routes)\\n\\npage router 방식에서 일반적인 Dynamic Routes 구현에 useRouter를 사용합니다.\\n아래는 클라이언트 사이드에서의 데이터 페칭을 위해 useEffect 내부에서 fetch 함수를 사용하고 가져온 데이터를 post 상태 변수에 할당하는 코드입니다.\\n\\n\\n// src/pages/posts-csr/[id].tsx\\nimport { useRouter } from \\\"next/router\\\";\\nimport { useEffect, useState } from \\\"react\\\";\\nimport { Post } from \\\"../types/posts\\\";\\n\\nexport default function PostDetail() {\\n  const router = useRouter();\\n  const { id } = router.query;\\n\\n  const [post, setPost] = us\",\"fileNameWithoutExtension\":\"250417_commit\"},{\"frontmatter\":{\"title\":\"ts 파일 실행하기\",\"created_at\":\"2025-02-07\",\"updated_at\":\"2025-02-07\",\"tags\":[\"typescript\",\"node\",\"ts-node\",\"tsx\",\"module\",\"commonjs\",\"import\",\"require\",\"ts\"]},\"preview\":\"로컬 데이터베이스인 SQLite를 이용하다 보면 가끔 db 내의 데이터를 모두 삭제해야 할 필요가 있을 때가 있습니다.\\n\\n이럴 때 db 내 데이터를 삭제하는 코드를 담은 .ts 파일을 생성하여 실행하는 방식으로 하는데, 새로 생성한 nextjs 프로젝트에서 .ts 파일을 실행하려 하자 여러 가지 문제가 발생했습니다.\\n\\n아래는 문제가 된 파일입니다.\\n\\n\\n// deleteALLData.ts\\nimport { PrismaClient } from \\\"@prisma/client\\\";\\n\\nconst prisma = new PrismaClient();\\n\\nasync function deleteAllData() {\\n  try {\\n    await prisma.memo.deleteMany();\\n    console.log(\\\"All memo data deleted\\\");\\n  } catch (error) {\\n    console.error(\\\"Error deleting data: \\\", error);\\n  }\\n}\\n\\ndeleteAllData();\\n\\n\\n\\n ts 확장자 파일 실행하기와 Trouble 발생\\n\\nnode 명령어로는 .js 확장자 파일만 실행이 가능합니다. .ts 확장자 파일을 실행하기 위해서는 ts-node 패키지의 추가 설치가 필요합니다.\\n\\n\\nnpm install ts-node --save-dev\\n\\n\\nts-node 설치 후 파일 실행 명령어를 입력합니다.\\n\\n\\nn\",\"fileNameWithoutExtension\":\"250207_commit\"},{\"frontmatter\":{\"title\":\"prisma schema model 수정하기\",\"created_at\":\"2025-02-06\",\"updated_at\":\"2025-02-06\",\"tags\":[\"prisma\",\"model\",\"db\"]},\"preview\":\"model 수정하기\\n\\n기존 Memo model에는 isPublic 이라는 boolean 타입의 field가 포함되어 있었습니다.\\n\\n초기 memo-board 앱에는 Group model 없었고 메모는 public/private 두 가지 타입만 존재했기에 isPublic 필드로 데이터를 표현하기에 충분했습니다.\\n\\n하지만 Group model을 추가하고 난 후에는 해당 그룹에 속하는 그룹원들에게만 보이는 메모 타입이 필요해졌습니다. isPublic  필드 대신 public/private/group으로 구분하는 새로운 필드를 사용하기로 합니다.\\n\\nPUBLIC/PRIVATE/GROUP 으로 정의된 Visibility 라는 enum 타입을 추가하고 Memo model에 isPublic field 대신 Visibility 타입의 visibility 필드를 추가합니다. 기본값은 PRIVATE으로 주었습니다.\\n\\n\\n (수정 전 Memo model)\\n\\n\\n (수정 후 Memo model)\\n\\n\\n\\n\\n 바뀐 model에 맞도록 코드 수정하기\\n\\nmemo.isPublic의 boolean 값으로 조건 검사를 하던 코드는 memo.visibility === Visibility.Public으로 수정합니다.\\n\\nform을 이용해 memo를 create하던 코드는 form에 visibility 항목을 추가하고, memo를 edit하던 코드에도 isPublic 을 visibi\",\"fileNameWithoutExtension\":\"250206_commit\"},{\"frontmatter\":{\"title\":\"리액트 JS 프로젝트(animal-friends) 리팩토링\",\"created_at\":\"2025-01-06\",\"updated_at\":\"2025-04-28\",\"tags\":[\"react\",\"CRA\",\"vite\",\"refactoring\"]},\"preview\":\"프로젝트 주소\\n\\nhttps://animal-friends-ts.netlify.app\\n\\n\\nanimal freidns 애플리케이션은 React 학습 후 처음 만든 포트폴리오 프로젝트입니다.\\n\\nCRA로 생성한 React JS 프로젝트이며 기능이 작동하는 것에 주안점을 두고 구축하다 보니 내부 구조가 좋지 못했습니다. 애플리케이션의 더 매끄러운 작동을 위해 리팩토링을 하기로 합니다.\\n\\n리팩토링 과정은 아래의 단계로 진행하였습니다.\\n\\n\\n1. Vite 프로젝트 생성 및 환경 변수 수정\\n2. javascript 파일들을 typescript 파일로 변환(일단 작동하게만)\\n3. UserContext과 useAuth hook 코드 정리\\n\\n\\n\\n 1. Vite 프로젝트 생성 및 환경 변수 수정\\n\\n기존의 프로젝트는 CRA으로 만든 프로젝트였으나 리팩토링 프로젝트는 Vite를 사용하였습니다.\\n\\nREACT_APP_으로 시작하던 환경 변수들을 VITE_로 시작하도록, process.env. 접두어를 붙여 사용하던 환경 변수들은 import.meta.env. 접두어를 사용하도록 수정하였습니다.\\n\\n\\n 2. javascript 파일들을 typescript 파일로 변환\\n\\n 자바스크립트 파일을 타입스크립트 파일로 변경하기\\n\\n프로젝트 내 js, jsx 파일들의 확장자를 ts, tsx 확장자로 변경하였으며, 타입스크립트 파일들 내에 필요한 타입들을 추가해주었습니다.\\n\\n파일 \",\"fileNameWithoutExtension\":\"250106_commit\"},{\"frontmatter\":{\"title\":\"memo editing 기능 구현하기\",\"created_at\":\"2024-12-05\",\"updated_at\":\"2024-12-05\",\"tags\":[\"nextjs\",\"react\",\"dynamic_routes\",\"generateStaticParams\",\"server_action\"]},\"preview\":\"생성된 메모의 title이나 description을 수정 후 다시 db에 저장하는 기능을 구현하려고 합니다.\\n\\n\\n Dynamic routes를 이용한 memo edit 페이지 생성\\n\\n각 메모별 별도의 edit 페이지를 가지게 하기 위해 dynamic route 를 이용합니다.\\n메모 수정 작업은 /memos/[id]/edit 페이지에서 수행되며, [id] 부분 즉, dynamic segments 부분은 build time에 채워넣어 집니다.\\n\\nparams prop은 Promise 입니다. 따라서 async/await 를 사용해야 합니다.\\n\\n\\n// memo-board/src/app/memos/[id]/edit/page.tsx\\n\\nimport { db } from \\\"@/app/db\\\";\\nimport { notFound } from \\\"next/navigation\\\";\\nimport MemoEditSection from \\\"./memo-edit-section\\\";\\n\\nexport default async function MemoEdit({\\n  params,\\n}: {\\n  params: Promise\u003c{ id: string }\u003e;\\n}) {\\n  const { id } = await params;\\n  const memo = await db.memo.findFirst({\\n    where: { id: parseInt(id) },\\n  });\\n  if (!memo) \",\"fileNameWithoutExtension\":\"241205_commit\"},{\"frontmatter\":{\"title\":\"memo creation 기능 구현하기\",\"created_at\":\"2024-12-01\",\"updated_at\":\"2024-12-01\",\"tags\":[\"nextjs\",\"useActionState\",\"form\",\"react\",\"prisma\"]},\"preview\":\"새로운 메모 생성을 위해 필요한 것들\\n\\n메모 생성 페이지에서 메모의 제목과 내용을 입력하고 Create 버튼을 클릭하면 새로운 메모가 생성되게 하려고 합니다.\\n\\nprisma.schema에서 Memo model을 살펴봅니다.\\nMemo model은 id, title, content 필드로 구성되어 있습니다.\\n\\n\\n// prisma.schema\\n...\\nmodel Memo {\\n  id    Int    @id @default(autoincrement())\\n  title String\\n  content  String\\n}\\n...\\n\\n\\n메모 생성 기능 구현에 필요한 구체적인 것들을 정리합니다.\\n\\n- title, content 항목을 포함하는 클라이언트 컴포넌트의 form\\n- form 제출 시, form data를 받아서 필요한 로직을 수행하는 서버 컴포넌트 함수\\n\\t- form validation\\n\\t- create 메서드 호출을 통한 데이터 생성\\n\\n\\n\\n 메모 생성 기능 구현하기\\n\\n 생성할 memo data의 form 제출 구현(client component)\\n\\nform 제출에는 useActionState 리액트 훅을 사용합니다.\\n형식은 아래와 같습니다.\\n\\n\\nconst [state, formAction, isPending] = useActionState(fn, initialState, permalink?);\\n\\n\\n폼의 제출 과정 중 발생하는 에러를 mess\",\"fileNameWithoutExtension\":\"241201_commit\"},{\"frontmatter\":{\"title\":\"블로그 포스트 내 이미지 변환 로직 변경하기(with supabase)\",\"created_at\":\"2024-11-28\",\"updated_at\":\"2024-11-28\",\"tags\":[\"supabase\"]},\"preview\":\"Trouble\\n\\n기존의 이미지 텍스트를 image url로 변환하는 로직은 단순히 index 의 숫자를 하나씩 증가 시켜 가면서 매칭시켰기 때문에 반드시 포스트 내 이미지의 순서와 supabase storage로부터 가져온 이미지 파일의 순서가 일치해야만 정상적으로 작동하는 로직이었습니다.\\n\\n게다가 supabase의 storage로부터 파일명 리스트를 가져오는 .list 함수의 sortBy 옵션은 기본값을 제공하고 있지 않은데 기존의 코드는 sortBy 옵션을 지정해 두지도 않은 상태였습니다. 그럼에도 기본적으로 supabase storage 내에서의 파일 정렬이 파일의 Name 기준 오름차순으로 되어 있어 우연히 문제가 발생하지 않았던 것으로 보입니다.\\n\\n이미지 url 변환을 단순 index에 의존하지 않고 이미지 파일명과 분명하게 매칭되는 경우에만 해당 파일명을 이미지 url로 변환하도록 합니다.\\n\\n또한, 블로그 포스트에 쓰이는 이미지의 양이 방대하지 않은데 각각의 폴더로 별도로 저장하는 로직이 불필요하다는 생각이 들어 기존의 post title에 따라 각각 별도의 폴더에 이미지를 저장하던 방식에서 하나의 images 폴더에 해당 페이지의 전체 포스트 이미지들을 저장하는 방식으로 수정하기로 하였습니다.\\n\\n Trouble 해결\\n\\n 수정 전 코드\\n\\n\\nconst { data: imageFileList, error } = await su\",\"fileNameWithoutExtension\":\"241128_commit\"},{\"frontmatter\":{\"title\":\"useSWR fallbackData 옵션 관련 이슈 처리\",\"created_at\":\"2024-11-26\",\"updated_at\":\"2024-11-26\",\"tags\":[\"swr\",\"fallbackData\",\"useSWR\"]},\"preview\":\"Trouble\\n\\nuseSWR에서 fallbackData 옵션 사용 시, revalidateIfStale 옵션을 false로 두면 limit 값을 변경해도 refetch가 일어나지 않는 문제가 발생하였습니다.\\n\\n\\nconst { data, isLoading, error } = useSWR([page, limit, order],{\\n\\tfallbackData: initialTodos,\\n\\trevalidateIfStale: false,\\n});\\n\\n\\nrevalidateIfStale을 false 로 둔 이유는 default 값인 true로 둘 경우 limit 값을 변경할 때마다 이전에 이미 불러온 데이터임에도 캐시 데이터를 사용하지 않고 refetch가 일어났기 때문입니다.\\n\\n Trouble 원인\\n\\n\\nhttps://github.com/vercel/swr/issues/284\\n\\n\\n위의 사이트를 참고하여 문제의 원인을 파악할 수 있었습니다. \\n\\nfallbackData는 각 key 값에 대해 초기값으로 할당되는 데이터입니다. \\n즉, limit을 변경하여 key 값이 변경되면 해당 key에 다시 fallbackData가 할당되며 revalidateIfStale이 false로 설정되어 있으므로 refetch가 일어나지 않고, limit 값이 또 바뀌어도 해당 키에 다시 fallbackData가 할당될 뿐이므로 데이터 리페칭이 일어나지 않는 것이었습니다. \\n\\n T\",\"fileNameWithoutExtension\":\"241126_commit\"},{\"frontmatter\":{\"title\":\"Github blog 배포 에러 처리하기\",\"created_at\":\"2024-11-18\",\"updated_at\":\"2024-11-18\",\"tags\":[\"github_blog\",\"deploy\",\"github_pages\"]},\"preview\":\"Trouble: 배포 에러\\n\\ngithub pages를 이용한 github 블로그 배포 중 여러가지 에러가 발생하였습니다.\\n\\n 배포 에러 1. 타입 에러\\n\\n\\n\\ngenerateStaticParams가 반환하는 값의 타입이 { slug: string }[]이어야 하는데, 반환되는 값에 undefined가 포함될 가능성이 있기 때문에 발생하는 오류입니다.\\n\\n 수정 전 코드\\n\\nexport async function generateStaticParams() {\\n  const slugs = await getPostTitles({ page: \\\"commit-logs\\\" });\\n\\n  return slugs?.map((slug) =\u003e ({ slug }));\\n}\\n\\n\\n 수정 후 코드\\n\\nexport async function generateStaticParams() {\\n  const slugs = await getPostTitles({ page: \\\"commit-logs\\\" });\\n\\n  return (slugs ?? []).map((slug) =\u003e ({ slug }));\\n}\\n\\n\\n\\n 배포 에러 2. React Hook 함수의 부적절한 사용\\n\\n\\n\\n 배포 에러 2-1.\\n\\nuseMDXComponents 라는 React Hook이 getMetadata라는 함수 내에서 호출되고 있는 것이 문제입니다. useMDXComponents 함수의 함수명을 getMDXComponent\",\"fileNameWithoutExtension\":\"241118_commit\"},{\"frontmatter\":{\"title\":\"Cart feature 리팩토링\",\"created_at\":\"2024-11-15\",\"updated_at\":\"2024-11-15\",\"tags\":[\"react-redux\",\"createSelector\"]},\"preview\":\"리팩토링1: totalValue 계산을 slice 파일로 옮기기\\n\\n 코드 수정 전\\n\\n\\n// Cart.tsx\\n...\\nexport const Cart = () =\u003e {\\n  const dispatch = useAppDispatch();\\n  const { items: itemList, searchTerm } = useAppSelector(selectCart);\\n\\n  const [itemName, setItemName] = useState\u003cstring\u003e(\\\"\\\");\\n  const [itemValue, setItemValue] = useState\u003cnumber\u003e(0);\\n  const [totalValue, setTotalValue] = useState\u003cnumber\u003e(0);\\n\\n  useEffect(() =\u003e {\\n    setTotalValue(itemList.reduce((acc, item) =\u003e acc + item.value, 0));\\n  }, [itemList]);\\n  ...\\n}\\n\\n\\n\\n// cartSlice.ts\\n...\\nexport const selectCart = ({ cart: { searchTerm, items } }: RootState) =\u003e {\\n  const filteredItems = items.filter((item) =\u003e\\n    item.name.toLocaleLowerCase().includes(searchTerm.toLowerCa\",\"fileNameWithoutExtension\":\"241115_commit\"},{\"frontmatter\":{\"title\":\"tailwindcss 동적 클래스 이름(dynamic class name) 사용하기\",\"created_at\":\"2024-11-05\",\"updated_at\":\"2024-11-05\",\"tags\":[\"tailwindcss\",\"dynamic_class_name\"]},\"preview\":\"Trouble: tailwindcss에서 템플릿 리터럴(template literal) 사용이 안 돼요\\n\\ntailwindcss에서 당연히 가능할 것 같았던 문법이 제대로 동작하지 않습니다. 아래와 같은 템플릿 리터럴 부분입니다.\\n\\n\\nconst bgColor = bg-${color}-300;\\n\\n\\n문제가 되는 부분의 코드는 아래와 같습니다.\\n\\n\\n{dayTodos.map((todo, index) =\u003e {\\n\\t...\\n\\tconst topClass = top-${4 + todo.index * 4};\\n\\tconst bgColor = bg-${todo.color}-300;\\n\\treturn (\\n\\t\\t\u003cdiv\\n\\t\\t  key={index}\\n\\t\\t  className={absolute ${topClass} left-0 w-full h-4 z-0 ${bgColor}}\u003e\u003c/div\u003e\\n\\t);\\n\\t})}\\n\\n\\n공식 문서를 찾아보면 Don’t use props to build class names dynamically라고 안내하고 있습니다.\\n\\nclass names을 동적으로 사용하면 안되며 항상 완전한 class names를 사용하라고 합니다.\\n\\n\\n// error code\\n\u003cdiv class=\\\"text-{{ error ? 'red' : 'green' }}-600\\\"\u003e\u003c/div\u003e\\n\\n\\n\\n// error code\\nfunction Button({ color, children }) {\\n \",\"fileNameWithoutExtension\":\"241105_commit\"},{\"frontmatter\":{\"title\":\"Form update 하기(with RHF)\",\"created_at\":\"2024-11-03\",\"updated_at\":\"2024-11-08\",\"tags\":[\"react-hook-form\",\"RHF\"]},\"preview\":\"Q. Form을 수정하려면 어떻게 해야 할까요?\\n\\n\\n 저장된 값 띄우기\\n\\ntodo card의 edit 버튼을 클릭하면 저장된 값들이 form에 떠야합니다.\\n\\n 시도 1. setValue 이용하기\\n\\ngetTodoById 함수를 이용하여 DB로부터 해당 todo 에 대한 정보를 가져오고 setValue를 이용하여 값을 하나하나 입력해주는 방식입니다.\\n\\n\\n  useEffect(() =\u003e {\\n    const fetchTodoById = async () =\u003e {\\n      if (todoIdToUpdate) {\\n        todoToUpdate = await getTodoById(todoIdToUpdate);\\n        const {\\n          task,\\n          category,\\n          priority,\\n          startTimeStamp,\\n          endTimeStamp,\\n          memo,\\n          status,\\n        } = todoToUpdate;\\n        const [startDate, startTime] = startTimeStamp.slice(0, -4).split(\\\"T\\\");\\n        const [endDate, endTime] = endTimeStamp.slice(0, -4).split(\\\"T\\\");\\n\\n        const dateOnly\",\"fileNameWithoutExtension\":\"241102-241103_commit\"},{\"frontmatter\":{\"title\":\"CompileMDX로 frontmatter 데이터 분리하기\",\"created_at\":\"2024-10-09\",\"updated_at\":\"2024-10-09\",\"tags\":[\"nextjs\",\"typescript\"]},\"preview\":\"Trouble: CompileMDX 함수의 리턴 타입 에러\\n\\n\\ngetMetadata 함수에 리턴 타입 지정을 하지 않았더니 frontmatter 데이터의 title을 출력했을 때 맞는 문자열들이 화면에 출력되기는 하지만 코드 자체에 빨간색으로 에러 표시가 생겼습니다.\\n\\n\\nasync function getMetadata({ source }: { source: string }) {\\n  return await compileMDX({\\n    source,\\n    options: {\\n      parseFrontmatter: true,\\n    },\\n  });\\n}\\n\\n\\n\\n\\n그래서 mdx post들의 타입 지정을 하고 getMetadata 함수에 리턴 타입을 할당해 주었습니다.\\n\\n\\nexport type MDXPost = {\\n  content: string;\\n  frontmatter: { title: string; date: string; tags: string[] };\\n};\\n\\n\\n\\nasync function getMetadata({\\n  source,\\n}: {\\n  source: string;\\n}): Promise\u003cCompileMDXResult\u003cMDXPost\u003e\u003e {\\n  return await compileMDX({\\n    source,\\n    options: {\\n      parseFrontmatter: true,\\n    },\\n  });\\n}\\n\\n\\n그런데 \",\"fileNameWithoutExtension\":\"241009_commit\"},{\"frontmatter\":{\"title\":\"마크다운 인라인 코드(inline code)의 백틱 표시 제거하기\",\"created_at\":\"2024-10-08\",\"updated_at\":\"2024-10-08\",\"tags\":[\"nextjs\",\"markdown\",\"html\",\"prose\"]},\"preview\":\"Trouble: 왜 자꾸 백틱(\\\\)이 화면에 나타날까요?\\n\\n\\n\\nmdx 파일에서는 inline code로 감싸져 효과만 주던 백틱이 MDXRemote 로 렌더링 된 후에는 백틱까지 화면에 나타납니다.\\n\\n\u003cMDXRemote /\u003e는 MDX 콘텐츠를 HTML로 변환하여 화면에 렌더링되도록 해주는 함수입니다.\\n\\n삼중 백틱(\\\\\\\\\\\\\\\\)의 경우 \u003cpre\u003e\u003ccode\u003e...\u003c/code\u003e\u003c/pre\u003e로 변환되지만 와 백틱 하나(\\\\)의 경우 \u003ccode\u003e...\u003c/code\u003e로 변환됩니다.\\n\\n그런데 화면에 렌더링 시, 삼중 백틱은 나타나지 않지만 백틱은 나타납니다. \\n\\n\\n\\n보기에 좋지가 않기에 인라인 코드 좌우의 단일 백틱 제거가 필요합니다.\\n\\n\\n\\n Trouble 원인 찾기\\n\\n 가설1. MDXRemote가 백틱을 포함한 html element 로 변환해 주는 걸까요?\\n\\n이유는 알 수 없지만 MDXRemote 가 백틱을 단순히 \u003ccode\u003e...\u003c/code\u003e가 아닌 \u003ccode\u003e\\\\...\\\\\u003c/code\u003e로 변환해주는 문제인지 테스트를 해봅니다.\\n\\nmdx-components.tsx 파일 내 code 부분에 정규표현식을 이용하여 백틱 문자 제거 후 렌더링하여 봅니다.\\n\\nexport function useMDXComponents(components: MDXComponents): MDXComponents {\\n\\n  return {\\n    ...,\\n\\tcode: ({ children\",\"fileNameWithoutExtension\":\"241008_commit\"},{\"frontmatter\":{\"title\":\"블로그 포스트 내 이미지 띄우기(with supabase)\",\"created_at\":\"2024-10-07\",\"updated_at\":\"2024-10-07\",\"tags\":[\"supabase\",\"nextjs\",\"react\",\"regular_expression\",\"sql\"]},\"preview\":\"getMDXPosts는 posts 버킷의 mdx 폴더의 파일 리스트를 가져와 해당 파일들을 다운로드 후 텍스트 변환하고 string[] 타입으로 반환하는 함수입니다.\\n \\njavascript\\nexport async function getMDXPosts() {\\n  const { data: fileList, error } = await supabase.storage\\n    .from(\\\"posts\\\")\\n    .list(\\\"mdx\\\");\\n\\n  if (error) {\\n    console.error(\\\"Error occurred while loading the file list:\\\", error.message);\\n    return [];\\n  }\\n\\n  const posts = [];\\n\\n  for (const file of fileList) {\\n    const { data, error } = await supabase.storage\\n      .from(\\\"posts\\\")\\n      .download(mdx/${file.name});\\n\\n    if (error) {\\n      console.error(Error downloading file ${file.name}:, error.message);\\n      continue;\\n    }\\n    const text = await data.text();\\n    posts.push(text);\\n  }\\n\\n  ret\",\"fileNameWithoutExtension\":\"241006-241007_commit\"}]}]}]]}]\n"])</script></body></html>