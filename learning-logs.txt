3:I[9275,[],""]
4:I[1343,[],""]
5:I[5767,["231","static/chunks/231-6a7b6dfd7bcbf59a.js","185","static/chunks/app/layout-446e62b86e627af0.js"],"PostProvider",1]
6:I[231,["231","static/chunks/231-6a7b6dfd7bcbf59a.js","185","static/chunks/app/layout-446e62b86e627af0.js"],""]
0:["QPOD-7M2dUX1Dov1x8aip",[[["",{"children":["learning-logs",{"children":["__PAGE__",{}]}]},"$undefined","$undefined",true],["",{"children":["learning-logs",{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","learning-logs","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/a13b559d67687ed0.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","$L5",null,{"children":["$","body",null,{"className":"__variable_1e4310 __variable_c3aa02 antialiased","children":[["$","nav",null,{"className":"font-mono mx-16","children":["$","ul",null,{"className":"relative min-h-32 m-14 mb-10 flex flex-col md:flex-row md:space-x-12 space-y-1 justify-center md:justify-start items-center text-2xl md:text-3xl z-0 tracking-tight text-zinc-900","children":[["$","li",null,{"children":["$","$L6",null,{"href":"/","children":"Home"}]}],["$","li",null,{"children":["$","$L6",null,{"href":"/learning-logs","children":"Learning Logs"}]}],["$","li",null,{"children":["$","$L6",null,{"href":"/commit-logs","children":"Commit logs"}]}]]}]}],["$","div",null,{"className":"flex justify-center py-10","children":["$","div",null,{"className":"page-background","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]}]]}]}]}]],null],null],[null,"$L7"]]]]
7:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Create Next App"}],["$","meta","3",{"name":"description","content":"Generated by create next app"}]]
1:null
8:I[9077,["231","static/chunks/231-6a7b6dfd7bcbf59a.js","595","static/chunks/app/learning-logs/page-c7849050a8c0ccb8.js"],"DateFilterNav",1]
9:I[9859,["231","static/chunks/231-6a7b6dfd7bcbf59a.js","595","static/chunks/app/learning-logs/page-c7849050a8c0ccb8.js"],"default",1]
2:["$","div",null,{"className":"flex h-full mr-5","children":[["$","$L8",null,{"postDates":["2024-10-19","2024-10-15","2024-10-07"],"className":"bg-teal-700 border-teal-950"}],["$","div",null,{"className":"flex overflow-y-auto","children":["$","$L9",null,{"postSummaries":[{"frontmatter":{"title":"인터페이스(interface)와 타입 별칭(type alias)","created_at":"2024-10-19","updated_at":"2024-10-19","tags":["interface","type_alias"]},"preview":"타입스크립트에서 인터페이스와 타입 별칭은 객체의 구조를 정의하는 데 사용됩니다.\n\n 인터페이스(interface)\n\n인터페이스는 클래스와 같은 구조체의 형식을 정의하는 데 많이 사용되며 다른 인터페이스로부터 상속받을 수 있습니다. interface 키워드를 사용하여 정의합니다.\n\n\n// interface example\n\ninterface Person {\n  name: string;\n  age: number;\n}\n\ninterface Employee extends Person {\n    employeeId: number;\n}\n\n\n여러 개의 인터페이스를 병합할 수도 있습니다. 동일한 이름의 인터페이스를 여러 번 정의하면 TypeScript는 이를 자동으로 병합하여 하나의 인터페이스로 만들어줍니다.\n\n\ninterface Person {\n  name: string;\n}\n\ninterface Person {\n  age: number;\n}\n\ninterface Person {\n  address: string;\n}\n\n// 병합된 Person 인터페이스\ninterface Person {\n  name: string;\n  age: number;\n  address: string;\n}\n\n\n\n 타입 별칭(type alias)\n\n특정 타입에 대해 별칭을 만드는 방법으로 type 키워드를 사용하여 정의합니다.\n기본 타입, 유니언 타입, 튜플 타입 등 다양한 타입을 ","fileNameWithoutExtension":"interface_and_type_alias"},{"frontmatter":{"title":"얕은 복사(shallow copy)와 깊은 복사(deep copy)","created_at":"2024-10-15","updated_at":"2024-10-15","tags":["shallow_copy","deep_copy","primitive_type","reference_type","value_type"]},"preview":"얕은 복사(shallow copy): copy by value + copy by reference\n\n얕은 복사는 iterable(객체, 배열, 등)의 최상위 요소들만 복사하고, 하위 요소는 원본과 동일한 참조(reference)를 공유하는 방식입니다.\n\n얕은 복사는 하위 요소에 대해 참조(reference)만을 복사하기 때문에 **더 빠르게 동작**하고 **더 적은 메모리**를 사용합니다. 하지만, 참조의 공유는 원본 요소나 복사된 요소의 변경이 예상치 못한 결과로 이어질 수 있기 때문에 사용에 주의가 필요합니다.\n\n 얕은 복사의 예\n\n- Object.assign()\n- Spread Operator(...)\n- Array.prototype.slice()\n- Array.prototype.concat()\n\n\n\n 깊은 복사(deep copy): copy by value\n\n깊은 복사는 독립적인 새로운 객체를 만드는 방식입니다. 원본 객체에서 값 만을 복사하므로 복사된 객체를 수정해도 원본 객체에 영향을 미치지 않습니다. \n\n\n 깊은 복사의 예\n\n- JSON.parse(JSON.stringify())\n\n\n\n 예: Todo 객체로 알아보는 얕은 복사와 깊은 복사\n\n\n예시에 사용할 중첩 객체(nested object) todo\n\ninterface Todo {\n  id: number;\n  task: string;\n  category: string;","fileNameWithoutExtension":"shallow_copy_and_deep_copy"},{"frontmatter":{"title":"정규 표현식(regular expression)","created_at":"2024-10-07","updated_at":"2024-10-22","tags":["regular_expression"]},"preview":"정규 표현식\n\n정규 표현식이란 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어(특정한 법칙들에 따라 적절하게 구성된 문자열들의 집합)입니다.\n\n replace 함수\n\n\nreplace(pattern, replacement)\n\n\n- replace 함수의 첫 번째 인자는 문자열 또는 Symbol.replace 메서드를 가진 객체(예: 정규표현식)입니다.\n- 두 번째 인자는 문자열 또는 함수입니다.\n\n\n 정규 표현식 예시 모음\n\n 예시1: ![[...]] 패턴을 찾기 위한 정규 표현식\n\n\n/!\\[\\[.*?\\]\\]/g\n\n\n /.../g\n- /는 정규 표현식의 시작과 끝을 나타냅니다.\n- g는 전역 플래그(Global flag)로 텍스트 전체에서 모든 일치 항목을 찾도록 합니다.\n\n !\\[\\[ 와 \\]\\]\n- 이스케이프 문자('\\')를 포함한 ![[...]]\n\n .*?\n- .는 임의의 단일 문자를 의미합니다.\n- *는 0번 이상의 반복을 의미합니다.\n- ?는 Non-greedy 모드를 의미합니다. 기본적으로 *는 가능한 많은 문자를 포함하려 하지만 ?가 있으면 가능한 적은 문자를 포함하게 됩니다. 즉, 첫번째 [[와 가장 가까운 ]]를 찾습니다.\n\n\n\n 예시2: 케밥 케이스 문자열을 카멜 케이스 문자열로 변환하기\n\n\nconst kebabStr = \"hello-world\";\nconst camelStr = kebabStr.rep","fileNameWithoutExtension":"regular_expression"}],"tagsClassName":"bg-emerald-500"}]}]]}]
