<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/2c8bd78face34764.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-3c60486726093425.js"/><script src="/_next/static/chunks/fd9d1056-42bca7a501e26700.js" async=""></script><script src="/_next/static/chunks/23-0400f1ada3445968.js" async=""></script><script src="/_next/static/chunks/main-app-e0d78c455d046f20.js" async=""></script><script src="/_next/static/chunks/231-6a7b6dfd7bcbf59a.js" async=""></script><script src="/_next/static/chunks/app/layout-9e882b25b1c0b5ce.js" async=""></script><script src="/_next/static/chunks/app/learning-logs/page-f1cd99967ca52527.js" async=""></script><title>Create Next App</title><meta name="description" content="Generated by create next app"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__variable_1e4310 __variable_c3aa02 antialiased"><nav class="font-mono mx-16"><ul class="relative min-h-32 m-14 mb-10 flex flex-col md:flex-row md:space-x-12 space-y-1 justify-center md:justify-start items-center text-2xl md:text-3xl z-0 tracking-tight text-zinc-900"><li><a href="/">Home</a></li><li><a href="/learning-logs">Learning Logs</a></li><li><a href="/commit-logs">Commit logs</a></li></ul></nav><div class="flex justify-center py-10"><div class="page-background"><div class="flex h-full mr-5"><nav class="min-w-30 font-thin text-lg mr-6"><ul><li class="flex justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md m-2 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-teal-700 border-teal-950">ALL</li><li class="flex justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md m-2 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-teal-700 border-teal-950"><span>24</span><span>-</span><span>10</span></li><li class="flex justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md m-2 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-teal-700 border-teal-950"><span>24</span><span>-</span><span>12</span></li></ul></nav><div class="flex overflow-y-auto"><div class="flex flex-col overflow-y-auto gap-5"><a class="flex flex-col w-full min-w-96 px-10 py-5  rounded-lg bg-white bg-opacity-50 no-underline" href="/learning-logs/Event Bubbling, Capturing, preventDefault, and stopPropagation"><h3 class="text-lg font-normal my-2 mb-0">Event Bubbling, Capturing, preventDefault  그리고 stopPropagation</h3><p class="flex justify-end">2024-12-13</p><div class="line-clamp-2">bubbling과 capturing

버블링(bubbling)과 캡쳐링(capturing)은 DOM에서 이벤트가 발생할 때 이벤트가 전파되는 방식에 대한 개념입니다.

버블링(bubbling)은 이벤트가 발생한 요소에서 시작하여 상위 요소들로 전파되는 것으로 이벤트 전파의 기본 동작입니다.
캡쳐링(capturing)은 버블링과 반대로, 이벤트가 상위 요소에서 시작하여 하위 요소로 전파되는 것으로 기본적으로 비활성화되어 있습니다.


 bubbling

버블링에서 이벤트는 DOM 트리를 따라 위로 올라가면서 부모 요소들에 전파됩니다. 최종적으로는 최상위 요소(window)까지 전파됩니다.


&lt;body&gt;
	&lt;div id=&quot;parent&quot;&gt;
	  &lt;button id=&quot;child&quot;&gt;Click me&lt;/button&gt;
	&lt;/div&gt;
	&lt;div id=&quot;sibling-of-parent&quot;&gt;&lt;/div&gt;
&lt;/body&gt;



document.getElementById(&quot;child&quot;).addEventListener(&quot;click&quot;, function() {
  console.log(&quot;child clicked!&quot;);
});
document.getElementById(&quot;parent&quot;).addEventListener(&quot;click&quot;, function() {
  console.log(&quot;parent clicked!&quot;);
});
document.getElementById(&quot;</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">preventDeafult</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">stopPropagation</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">bubbling</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">capturing</span></div></a><a class="flex flex-col w-full min-w-96 px-10 py-5  rounded-lg bg-white bg-opacity-50 no-underline" href="/learning-logs/interface_and_type_alias"><h3 class="text-lg font-normal my-2 mb-0">인터페이스(interface)와 타입 별칭(type alias)</h3><p class="flex justify-end">2024-10-19</p><div class="line-clamp-2">타입스크립트에서 인터페이스와 타입 별칭은 객체의 구조를 정의하는 데 사용됩니다.

 인터페이스(interface)

인터페이스는 클래스와 같은 구조체의 형식을 정의하는 데 많이 사용되며 다른 인터페이스로부터 상속받을 수 있습니다. interface 키워드를 사용하여 정의합니다.


// interface example

interface Person {
  name: string;
  age: number;
}

interface Employee extends Person {
    employeeId: number;
}


여러 개의 인터페이스를 병합할 수도 있습니다. 동일한 이름의 인터페이스를 여러 번 정의하면 TypeScript는 이를 자동으로 병합하여 하나의 인터페이스로 만들어줍니다.


interface Person {
  name: string;
}

interface Person {
  age: number;
}

interface Person {
  address: string;
}

// 병합된 Person 인터페이스
interface Person {
  name: string;
  age: number;
  address: string;
}



 타입 별칭(type alias)

특정 타입에 대해 별칭을 만드는 방법으로 type 키워드를 사용하여 정의합니다.
기본 타입, 유니언 타입, 튜플 타입 등 다양한 타입을 </div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">interface</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">type_alias</span></div></a><a class="flex flex-col w-full min-w-96 px-10 py-5  rounded-lg bg-white bg-opacity-50 no-underline" href="/learning-logs/shallow_copy_and_deep_copy"><h3 class="text-lg font-normal my-2 mb-0">얕은 복사(shallow copy)와 깊은 복사(deep copy)</h3><p class="flex justify-end">2024-10-15</p><div class="line-clamp-2">얕은 복사(shallow copy): copy by value + copy by reference

얕은 복사는 iterable(객체, 배열, 등)의 최상위 요소들만 복사하고, 하위 요소는 원본과 동일한 참조(reference)를 공유하는 방식입니다.

얕은 복사는 하위 요소에 대해 참조(reference)만을 복사하기 때문에 **더 빠르게 동작**하고 **더 적은 메모리**를 사용합니다. 하지만, 참조의 공유는 원본 요소나 복사된 요소의 변경이 예상치 못한 결과로 이어질 수 있기 때문에 사용에 주의가 필요합니다.

 얕은 복사의 예

- Object.assign()
- Spread Operator(...)
- Array.prototype.slice()
- Array.prototype.concat()



 깊은 복사(deep copy): copy by value

깊은 복사는 독립적인 새로운 객체를 만드는 방식입니다. 원본 객체에서 값 만을 복사하므로 복사된 객체를 수정해도 원본 객체에 영향을 미치지 않습니다. 


 깊은 복사의 예

- JSON.parse(JSON.stringify())



 예: Todo 객체로 알아보는 얕은 복사와 깊은 복사


예시에 사용할 중첩 객체(nested object) todo

interface Todo {
  id: number;
  task: string;
  category: string;</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">shallow_copy</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">deep_copy</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">primitive_type</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">reference_type</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">value_type</span></div></a><a class="flex flex-col w-full min-w-96 px-10 py-5  rounded-lg bg-white bg-opacity-50 no-underline" href="/learning-logs/regular_expression"><h3 class="text-lg font-normal my-2 mb-0">정규 표현식(regular expression)</h3><p class="flex justify-end">2024-10-07</p><div class="line-clamp-2">정규 표현식

정규 표현식이란 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어(특정한 법칙들에 따라 적절하게 구성된 문자열들의 집합)입니다.

 replace 함수


replace(pattern, replacement)


- replace 함수의 첫 번째 인자는 문자열 또는 Symbol.replace 메서드를 가진 객체(예: 정규표현식)입니다.
- 두 번째 인자는 문자열 또는 함수입니다.


 정규 표현식 예시 모음

 예시1: ![[...]] 패턴을 찾기 위한 정규 표현식


/!\[\[.*?\]\]/g


 /.../g
- /는 정규 표현식의 시작과 끝을 나타냅니다.
- g는 전역 플래그(Global flag)로 텍스트 전체에서 모든 일치 항목을 찾도록 합니다.

 !\[\[ 와 \]\]
- 이스케이프 문자(&#x27;\&#x27;)를 포함한 ![[...]]

 .*?
- .는 임의의 단일 문자를 의미합니다.
- *는 0번 이상의 반복을 의미합니다.
- ?는 Non-greedy 모드를 의미합니다. 기본적으로 *는 가능한 많은 문자를 포함하려 하지만 ?가 있으면 가능한 적은 문자를 포함하게 됩니다. 즉, 첫번째 [[와 가장 가까운 ]]를 찾습니다.



 예시2: 케밥 케이스 문자열을 카멜 케이스 문자열로 변환하기


const kebabStr = &quot;hello-world&quot;;
const camelStr = kebabStr.rep</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">regular_expression</span></div></a></div></div></div></div></div><script src="/_next/static/chunks/webpack-3c60486726093425.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/2c8bd78face34764.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n6:I[1343,[],\"\"]\n7:I[5767,[\"231\",\"static/chunks/231-6a7b6dfd7bcbf59a.js\",\"185\",\"static/chunks/app/layout-9e882b25b1c0b5ce.js\"],\"PostProvider\",1]\n8:I[231,[\"231\",\"static/chunks/231-6a7b6dfd7bcbf59a.js\",\"185\",\"static/chunks/app/layout-9e882b25b1c0b5ce.js\"],\"\"]\na:I[6130,[],\"\"]\nb:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L2\",null,{\"buildId\":\"m_q4X4krJg2lMvwBwtsAs\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"learning-logs\"],\"initialTree\":[\"\",{\"children\":[\"learning-logs\",{\"children\":[\"__PAGE__\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"learning-logs\",{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"learning-logs\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/2c8bd78face34764.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"$L7\",null,{\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_1e4310 __variable_c3aa02 antialiased\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"font-mono mx-16\",\"children\":[\"$\",\"ul\",null,{\"className\":\"relative min-h-32 m-14 mb-10 flex flex-col md:flex-row md:space-x-12 space-y-1 justify-center md:justify-start items-center text-2xl md:text-3xl z-0 tracking-tight text-zinc-900\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"$L8\",null,{\"href\":\"/\",\"children\":\"Home\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"$L8\",null,{\"href\":\"/learning-logs\",\"children\":\"Learning Logs\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"$L8\",null,{\"href\":\"/commit-logs\",\"children\":\"Commit logs\"}]}]]}]}],[\"$\",\"div\",null,{\"className\":\"flex justify-center py-10\",\"children\":[\"$\",\"div\",null,{\"className\":\"page-background\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]}]]}]}]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$L9\"],\"globalErrorComponent\":\"$a\",\"missingSlots\":\"$Wb\"}]\n"])</script><script>self.__next_f.push([1,"9:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Create Next App\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Generated by create next app\"}]]\n3:null\n"])</script><script>self.__next_f.push([1,"c:I[9077,[\"231\",\"static/chunks/231-6a7b6dfd7bcbf59a.js\",\"595\",\"static/chunks/app/learning-logs/page-f1cd99967ca52527.js\"],\"DateFilterNav\",1]\nd:I[9859,[\"231\",\"static/chunks/231-6a7b6dfd7bcbf59a.js\",\"595\",\"static/chunks/app/learning-logs/page-f1cd99967ca52527.js\"],\"default\",1]\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex h-full mr-5\",\"children\":[[\"$\",\"$Lc\",null,{\"postDates\":[\"2024-12-13\",\"2024-10-19\",\"2024-10-15\",\"2024-10-07\"],\"className\":\"bg-teal-700 border-teal-950\"}],[\"$\",\"div\",null,{\"className\":\"flex overflow-y-auto\",\"children\":[\"$\",\"$Ld\",null,{\"postSummaries\":[{\"frontmatter\":{\"title\":\"Event Bubbling, Capturing, preventDefault  그리고 stopPropagation\",\"created_at\":\"2024-12-13\",\"updated_at\":\"2024-12-13\",\"tags\":[\"preventDeafult\",\"stopPropagation\",\"bubbling\",\"capturing\"]},\"preview\":\"bubbling과 capturing\\n\\n버블링(bubbling)과 캡쳐링(capturing)은 DOM에서 이벤트가 발생할 때 이벤트가 전파되는 방식에 대한 개념입니다.\\n\\n버블링(bubbling)은 이벤트가 발생한 요소에서 시작하여 상위 요소들로 전파되는 것으로 이벤트 전파의 기본 동작입니다.\\n캡쳐링(capturing)은 버블링과 반대로, 이벤트가 상위 요소에서 시작하여 하위 요소로 전파되는 것으로 기본적으로 비활성화되어 있습니다.\\n\\n\\n bubbling\\n\\n버블링에서 이벤트는 DOM 트리를 따라 위로 올라가면서 부모 요소들에 전파됩니다. 최종적으로는 최상위 요소(window)까지 전파됩니다.\\n\\n\\n\u003cbody\u003e\\n\\t\u003cdiv id=\\\"parent\\\"\u003e\\n\\t  \u003cbutton id=\\\"child\\\"\u003eClick me\u003c/button\u003e\\n\\t\u003c/div\u003e\\n\\t\u003cdiv id=\\\"sibling-of-parent\\\"\u003e\u003c/div\u003e\\n\u003c/body\u003e\\n\\n\\n\\ndocument.getElementById(\\\"child\\\").addEventListener(\\\"click\\\", function() {\\n  console.log(\\\"child clicked!\\\");\\n});\\ndocument.getElementById(\\\"parent\\\").addEventListener(\\\"click\\\", function() {\\n  console.log(\\\"parent clicked!\\\");\\n});\\ndocument.getElementById(\\\"\",\"fileNameWithoutExtension\":\"Event Bubbling, Capturing, preventDefault, and stopPropagation\"},{\"frontmatter\":{\"title\":\"인터페이스(interface)와 타입 별칭(type alias)\",\"created_at\":\"2024-10-19\",\"updated_at\":\"2024-10-19\",\"tags\":[\"interface\",\"type_alias\"]},\"preview\":\"타입스크립트에서 인터페이스와 타입 별칭은 객체의 구조를 정의하는 데 사용됩니다.\\n\\n 인터페이스(interface)\\n\\n인터페이스는 클래스와 같은 구조체의 형식을 정의하는 데 많이 사용되며 다른 인터페이스로부터 상속받을 수 있습니다. interface 키워드를 사용하여 정의합니다.\\n\\n\\n// interface example\\n\\ninterface Person {\\n  name: string;\\n  age: number;\\n}\\n\\ninterface Employee extends Person {\\n    employeeId: number;\\n}\\n\\n\\n여러 개의 인터페이스를 병합할 수도 있습니다. 동일한 이름의 인터페이스를 여러 번 정의하면 TypeScript는 이를 자동으로 병합하여 하나의 인터페이스로 만들어줍니다.\\n\\n\\ninterface Person {\\n  name: string;\\n}\\n\\ninterface Person {\\n  age: number;\\n}\\n\\ninterface Person {\\n  address: string;\\n}\\n\\n// 병합된 Person 인터페이스\\ninterface Person {\\n  name: string;\\n  age: number;\\n  address: string;\\n}\\n\\n\\n\\n 타입 별칭(type alias)\\n\\n특정 타입에 대해 별칭을 만드는 방법으로 type 키워드를 사용하여 정의합니다.\\n기본 타입, 유니언 타입, 튜플 타입 등 다양한 타입을 \",\"fileNameWithoutExtension\":\"interface_and_type_alias\"},{\"frontmatter\":{\"title\":\"얕은 복사(shallow copy)와 깊은 복사(deep copy)\",\"created_at\":\"2024-10-15\",\"updated_at\":\"2024-10-15\",\"tags\":[\"shallow_copy\",\"deep_copy\",\"primitive_type\",\"reference_type\",\"value_type\"]},\"preview\":\"얕은 복사(shallow copy): copy by value + copy by reference\\n\\n얕은 복사는 iterable(객체, 배열, 등)의 최상위 요소들만 복사하고, 하위 요소는 원본과 동일한 참조(reference)를 공유하는 방식입니다.\\n\\n얕은 복사는 하위 요소에 대해 참조(reference)만을 복사하기 때문에 **더 빠르게 동작**하고 **더 적은 메모리**를 사용합니다. 하지만, 참조의 공유는 원본 요소나 복사된 요소의 변경이 예상치 못한 결과로 이어질 수 있기 때문에 사용에 주의가 필요합니다.\\n\\n 얕은 복사의 예\\n\\n- Object.assign()\\n- Spread Operator(...)\\n- Array.prototype.slice()\\n- Array.prototype.concat()\\n\\n\\n\\n 깊은 복사(deep copy): copy by value\\n\\n깊은 복사는 독립적인 새로운 객체를 만드는 방식입니다. 원본 객체에서 값 만을 복사하므로 복사된 객체를 수정해도 원본 객체에 영향을 미치지 않습니다. \\n\\n\\n 깊은 복사의 예\\n\\n- JSON.parse(JSON.stringify())\\n\\n\\n\\n 예: Todo 객체로 알아보는 얕은 복사와 깊은 복사\\n\\n\\n예시에 사용할 중첩 객체(nested object) todo\\n\\ninterface Todo {\\n  id: number;\\n  task: string;\\n  category: string;\",\"fileNameWithoutExtension\":\"shallow_copy_and_deep_copy\"},{\"frontmatter\":{\"title\":\"정규 표현식(regular expression)\",\"created_at\":\"2024-10-07\",\"updated_at\":\"2024-10-22\",\"tags\":[\"regular_expression\"]},\"preview\":\"정규 표현식\\n\\n정규 표현식이란 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어(특정한 법칙들에 따라 적절하게 구성된 문자열들의 집합)입니다.\\n\\n replace 함수\\n\\n\\nreplace(pattern, replacement)\\n\\n\\n- replace 함수의 첫 번째 인자는 문자열 또는 Symbol.replace 메서드를 가진 객체(예: 정규표현식)입니다.\\n- 두 번째 인자는 문자열 또는 함수입니다.\\n\\n\\n 정규 표현식 예시 모음\\n\\n 예시1: ![[...]] 패턴을 찾기 위한 정규 표현식\\n\\n\\n/!\\\\[\\\\[.*?\\\\]\\\\]/g\\n\\n\\n /.../g\\n- /는 정규 표현식의 시작과 끝을 나타냅니다.\\n- g는 전역 플래그(Global flag)로 텍스트 전체에서 모든 일치 항목을 찾도록 합니다.\\n\\n !\\\\[\\\\[ 와 \\\\]\\\\]\\n- 이스케이프 문자('\\\\')를 포함한 ![[...]]\\n\\n .*?\\n- .는 임의의 단일 문자를 의미합니다.\\n- *는 0번 이상의 반복을 의미합니다.\\n- ?는 Non-greedy 모드를 의미합니다. 기본적으로 *는 가능한 많은 문자를 포함하려 하지만 ?가 있으면 가능한 적은 문자를 포함하게 됩니다. 즉, 첫번째 [[와 가장 가까운 ]]를 찾습니다.\\n\\n\\n\\n 예시2: 케밥 케이스 문자열을 카멜 케이스 문자열로 변환하기\\n\\n\\nconst kebabStr = \\\"hello-world\\\";\\nconst camelStr = kebabStr.rep\",\"fileNameWithoutExtension\":\"regular_expression\"}],\"tagsClassName\":\"bg-emerald-500\"}]}]]}]\n"])</script></body></html>