<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/ec8169d84bc91095.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-cceda007551b34ac.js"/><script src="/_next/static/chunks/fd9d1056-42bca7a501e26700.js" async=""></script><script src="/_next/static/chunks/23-0400f1ada3445968.js" async=""></script><script src="/_next/static/chunks/main-app-e0d78c455d046f20.js" async=""></script><script src="/_next/static/chunks/231-6a7b6dfd7bcbf59a.js" async=""></script><script src="/_next/static/chunks/app/layout-c9173ec0898b2734.js" async=""></script><script src="/_next/static/chunks/app/learning-logs/page-4adb3f058fc7e2c3.js" async=""></script><title>Spaceofin Logs</title><meta name="description" content="A blog for study logs"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="256x256"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body><nav class="font-mono mx-16"><ul class="relative min-h-32 mt-14 mb-10 mx-2 sm:mx-12 lg:mx-14 flex flex-col md:flex-row md:space-x-12 lg:space-x-16 space-y-1 md:space-y-0 justify-center md:justify-start items-start sm:items-center md:items-center text-2xl md:text-3xl z-0 tracking-tight text-zinc-900 pl-4 sm:pl-0"><li><a href="/">Home</a></li><li><a href="/learning-logs">Learning Logs</a></li><li><a href="/commit-logs">Commit Logs</a></li></ul></nav><div class="flex justify-center py-10"><div class="page-background"><div class="flex flex-col sm:flex-row items-center sm:items-start justify-center h-full px-6 sm:px-0 sm:mr-5"><div class="flex w-full sm:max-w-[140px] flex-row sm:flex-col overflow-x-auto sm:overflow-x-visible mb-6 sm:mb-0 pb-2 sm:pb-0 pl-2 sm:pl-0"><nav class="font-thin text-lg mr-6"><ul class="flex flex-row sm:flex-col"><li class="flex w-[110px] justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md mx-2 my-1 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-teal-700 border-teal-950">ALL</li><li class="flex w-[110px] justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md mx-2 my-1 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-teal-700 border-teal-950"><span>24</span><span>-</span><span>10</span></li><li class="flex w-[110px] justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md mx-2 my-1 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-teal-700 border-teal-950"><span>24</span><span>-</span><span>12</span></li><li class="flex w-[110px] justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md mx-2 my-1 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-teal-700 border-teal-950"><span>25</span><span>-</span><span>02</span></li><li class="flex w-[110px] justify-center bg-indigo-800 bg-opacity-65 text-xl text-white font-mono rounded-md mx-2 my-1 ml-0 px-6 gap-0.5 border-2 border-indigo-950 border-opacity-70 hover:cursor-pointer bg-teal-700 border-teal-950"><span>25</span><span>-</span><span>03</span></li></ul></nav></div><div class="flex overflow-y-auto w-full"><div class="flex flex-col overflow-y-auto gap-5 w-full"><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/learning-logs/React.FC"><h3 class="text-lg font-normal my-2 mb-0">React.FC는 사용이 권장되지 않습니다</h3><p class="flex justify-end">2025-03-20</p><div class="line-clamp-2">React.FC는 React18 부터 사용 방식이 변경되었습니다

React.FC는 React 18부터 사용 방식이 변경되었습니다.

FunctoinComponent는 React17 버전 이하에서 함수형 컴포넌트를 정의할 때 사용되었으나 암묵적으로 children을 props 로 포함한다는 문제점을 가지고 있었습니다. React 18 버전에서 children props의 암묵적 포함 문제가 해결되었으나 필요한 경우 명시적으로 children을 props로 포함하는 방식이 더 낫기 때문에 React.FC의 사용은 권장되지 않습니다.

React18과 React17의 React.FC 정의를 살펴보면 아래와 같습니다.


// React18

type FC&lt;P = {}&gt; = FunctionComponent&lt;P&gt;;

interface FunctionComponent&lt;P = {}&gt; {
		(
				props: P,
				deprecatedLegacyContext?: any,
		): ReactNode;
		propTypes?: WeakValidationMap&lt;P&gt; | undefined;
		contextTypes?: ValidationMap&lt;any&gt; | undefined;
		defaultProps?: Partial&lt;P&gt; | undefined;
		displayName?: string | undefined;
}



// React17

</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">react</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/learning-logs/uri_url_and_urn"><h3 class="text-lg font-normal my-2 mb-0">URI, URL 그리고  URN</h3><p class="flex justify-end">2025-02-06</p><div class="line-clamp-2">- URI(Uniform Resource Identifier)
  : 자원을 고유하게 식별하는 모든 문자열로 URL과 URN을 포함하는 개념
- URL (Uniform Resource Locator)
  : 자원의 위치(경로)를 나타내는 URI
- URN(Uniform Resource Name)
  : 자원의 이름을 나타내는 URI


 URI(Uniform Resource Identifier)

URI는 자원을 식별하기 위한 모든 문자열을 의미합니다.
자원의 위치(URL) 또는 이름(URN)을 포함할 수 있으며, 자원을 고유하게 식별할 수 있는 기준입니다.
URI는 URL과 URN을 포함하는 상위 개념입니다.


&lt;예시&gt;
- URL: https://www.example.com/page (경로를 통해 자원을 식별)
- URN: urn:isbn:0451450523 (이름을 통해 자원을 식별)




 URL(Uniform Resource Loactor)

URL은 자원의 위치(경로)를 포함한 URI의 한 형태입니다.
자원에 접근하는 방법인 프로토콜(예: https, ftp)과 자원의 경로를 명시하여, 자원이 어디에 있고 어떻게 접근할 수 있는지를 알려줍니다.
브라우저의 주소창에서 입력하여 자원에 접근할 때 사용됩니다.

**URL의 구성 요소**
- 프로토콜(protocol): https://
- 도메인(domain): www.exam</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">URI</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">URL</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">URN</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/learning-logs/eventBubbling_capturing_preventDefault_and_stopPropagation"><h3 class="text-lg font-normal my-2 mb-0">Event Bubbling, Capturing, preventDefault  그리고 stopPropagation</h3><p class="flex justify-end">2024-12-13</p><div class="line-clamp-2">bubbling과 capturing

버블링(bubbling)과 캡쳐링(capturing)은 DOM에서 이벤트가 발생할 때 이벤트가 전파되는 방식에 대한 개념입니다.

버블링(bubbling)은 이벤트가 발생한 요소에서 시작하여 상위 요소들로 전파되는 것으로 이벤트 전파의 기본 동작입니다.
캡쳐링(capturing)은 버블링과 반대로, 이벤트가 상위 요소에서 시작하여 하위 요소로 전파되는 것으로 기본적으로 비활성화되어 있습니다.


 bubbling

버블링에서 이벤트는 DOM 트리를 따라 위로 올라가면서 부모 요소들에 전파됩니다. 최종적으로는 최상위 요소(window)까지 전파됩니다.


&lt;body&gt;
	&lt;div id=&quot;parent&quot;&gt;
	  &lt;button id=&quot;child&quot;&gt;Click me&lt;/button&gt;
	&lt;/div&gt;
	&lt;div id=&quot;sibling-of-parent&quot;&gt;&lt;/div&gt;
&lt;/body&gt;



document.getElementById(&quot;child&quot;).addEventListener(&quot;click&quot;, function() {
  console.log(&quot;child clicked!&quot;);
});
document.getElementById(&quot;parent&quot;).addEventListener(&quot;click&quot;, function() {
  console.log(&quot;parent clicked!&quot;);
});
document.getElementById(&quot;</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">preventDeafult</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">stopPropagation</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">bubbling</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">capturing</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/learning-logs/interface_and_type_alias"><h3 class="text-lg font-normal my-2 mb-0">인터페이스(interface)와 타입 별칭(type alias)</h3><p class="flex justify-end">2024-10-19</p><div class="line-clamp-2">타입스크립트에서 인터페이스와 타입 별칭은 객체의 구조를 정의하는 데 사용됩니다.

 인터페이스(interface)

인터페이스는 클래스와 같은 구조체의 형식을 정의하는 데 많이 사용되며 다른 인터페이스로부터 상속받을 수 있습니다. interface 키워드를 사용하여 정의합니다.


// interface example

interface Person {
  name: string;
  age: number;
}

interface Employee extends Person {
    employeeId: number;
}


여러 개의 인터페이스를 병합할 수도 있습니다. 동일한 이름의 인터페이스를 여러 번 정의하면 TypeScript는 이를 자동으로 병합하여 하나의 인터페이스로 만들어줍니다.


interface Person {
  name: string;
}

interface Person {
  age: number;
}

interface Person {
  address: string;
}

// 병합된 Person 인터페이스
interface Person {
  name: string;
  age: number;
  address: string;
}



 타입 별칭(type alias)

특정 타입에 대해 별칭을 만드는 방법으로 type 키워드를 사용하여 정의합니다.
기본 타입, 유니언 타입, 튜플 타입 등 다양한 타입을 </div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">interface</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">type_alias</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/learning-logs/shallow_copy_and_deep_copy"><h3 class="text-lg font-normal my-2 mb-0">얕은 복사(shallow copy)와 깊은 복사(deep copy)</h3><p class="flex justify-end">2024-10-15</p><div class="line-clamp-2">얕은 복사(shallow copy): copy by value + copy by reference

얕은 복사는 iterable(객체, 배열, 등)의 최상위 요소들만 복사하고, 하위 요소는 원본과 동일한 참조(reference)를 공유하는 방식입니다.

얕은 복사는 하위 요소에 대해 참조(reference)만을 복사하기 때문에 **더 빠르게 동작**하고 **더 적은 메모리**를 사용합니다. 하지만, 참조의 공유는 원본 요소나 복사된 요소의 변경이 예상치 못한 결과로 이어질 수 있기 때문에 사용에 주의가 필요합니다.

 얕은 복사의 예

- Object.assign()
- Spread Operator(...)
- Array.prototype.slice()
- Array.prototype.concat()



 깊은 복사(deep copy): copy by value

깊은 복사는 독립적인 새로운 객체를 만드는 방식입니다. 원본 객체에서 값 만을 복사하므로 복사된 객체를 수정해도 원본 객체에 영향을 미치지 않습니다. 


 깊은 복사의 예

- JSON.parse(JSON.stringify())



 예: Todo 객체로 알아보는 얕은 복사와 깊은 복사


예시에 사용할 중첩 객체(nested object) todo

interface Todo {
  id: number;
  task: string;
  category: string;</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">shallow_copy</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">deep_copy</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">primitive_type</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">reference_type</span><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">value_type</span></div></a><a class="flex flex-col w-full px-6 sm:px-10 py-5 rounded-lg bg-white bg-opacity-50 no-underline" href="/learning-logs/regular_expression"><h3 class="text-lg font-normal my-2 mb-0">정규 표현식(regular expression)</h3><p class="flex justify-end">2024-10-07</p><div class="line-clamp-2">정규 표현식

정규 표현식이란 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어(특정한 법칙들에 따라 적절하게 구성된 문자열들의 집합)입니다.

 replace 함수


replace(pattern, replacement)


- replace 함수의 첫 번째 인자는 문자열 또는 Symbol.replace 메서드를 가진 객체(예: 정규표현식)입니다.
- 두 번째 인자는 문자열 또는 함수입니다.


 정규 표현식 예시 모음

 예시1: ![[...]] 패턴을 찾기 위한 정규 표현식


/!\[\[.*?\]\]/g


 /.../g
- /는 정규 표현식의 시작과 끝을 나타냅니다.
- g는 전역 플래그(Global flag)로 텍스트 전체에서 모든 일치 항목을 찾도록 합니다.

 !\[\[ 와 \]\]
- 이스케이프 문자(&#x27;\&#x27;)를 포함한 ![[...]]

 .*?
- .는 임의의 단일 문자를 의미합니다.
- *는 0번 이상의 반복을 의미합니다.
- ?는 Non-greedy 모드를 의미합니다. 기본적으로 *는 가능한 많은 문자를 포함하려 하지만 ?가 있으면 가능한 적은 문자를 포함하게 됩니다. 즉, 첫번째 [[와 가장 가까운 ]]를 찾습니다.



 예시2: 케밥 케이스 문자열을 카멜 케이스 문자열로 변환하기


const kebabStr = &quot;hello-world&quot;;
const camelStr = kebabStr.rep</div><div class="flex flex-wrap my-2"><span class="bg-blue-500 bg-opacity-80 text-white rounded-xl pb-1 px-3 mr-2 my-1 whitespace-nowrap bg-emerald-500">regular_expression</span></div></a></div></div></div></div></div><script src="/_next/static/chunks/webpack-cceda007551b34ac.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/ec8169d84bc91095.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n6:I[1343,[],\"\"]\n7:I[5767,[\"231\",\"static/chunks/231-6a7b6dfd7bcbf59a.js\",\"185\",\"static/chunks/app/layout-c9173ec0898b2734.js\"],\"PostProvider\",1]\n8:I[231,[\"231\",\"static/chunks/231-6a7b6dfd7bcbf59a.js\",\"185\",\"static/chunks/app/layout-c9173ec0898b2734.js\"],\"\"]\na:I[6130,[],\"\"]\nb:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L2\",null,{\"buildId\":\"RXy6EsBE1La1Foi2c_t5-\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"learning-logs\"],\"initialTree\":[\"\",{\"children\":[\"learning-logs\",{\"children\":[\"__PAGE__\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"learning-logs\",{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"learning-logs\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ec8169d84bc91095.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"$L7\",null,{\"children\":[\"$\",\"body\",null,{\"children\":[[\"$\",\"nav\",null,{\"className\":\"font-mono mx-16\",\"children\":[\"$\",\"ul\",null,{\"className\":\"relative min-h-32 mt-14 mb-10 mx-2 sm:mx-12 lg:mx-14 flex flex-col md:flex-row md:space-x-12 lg:space-x-16 space-y-1 md:space-y-0 justify-center md:justify-start items-start sm:items-center md:items-center text-2xl md:text-3xl z-0 tracking-tight text-zinc-900 pl-4 sm:pl-0\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"$L8\",null,{\"href\":\"/\",\"children\":\"Home\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"$L8\",null,{\"href\":\"/learning-logs\",\"children\":\"Learning Logs\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"$L8\",null,{\"href\":\"/commit-logs\",\"children\":\"Commit Logs\"}]}]]}]}],[\"$\",\"div\",null,{\"className\":\"flex justify-center py-10\",\"children\":[\"$\",\"div\",null,{\"className\":\"page-background\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]}]]}]}]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$L9\"],\"globalErrorComponent\":\"$a\",\"missingSlots\":\"$Wb\"}]\n"])</script><script>self.__next_f.push([1,"9:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Spaceofin Logs\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"A blog for study logs\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"256x256\"}]]\n3:null\n"])</script><script>self.__next_f.push([1,"c:I[9077,[\"231\",\"static/chunks/231-6a7b6dfd7bcbf59a.js\",\"595\",\"static/chunks/app/learning-logs/page-4adb3f058fc7e2c3.js\"],\"DateFilterNav\",1]\nd:I[9859,[\"231\",\"static/chunks/231-6a7b6dfd7bcbf59a.js\",\"595\",\"static/chunks/app/learning-logs/page-4adb3f058fc7e2c3.js\"],\"default\",1]\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col sm:flex-row items-center sm:items-start justify-center h-full px-6 sm:px-0 sm:mr-5\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex w-full sm:max-w-[140px] flex-row sm:flex-col overflow-x-auto sm:overflow-x-visible mb-6 sm:mb-0 pb-2 sm:pb-0 pl-2 sm:pl-0\",\"children\":[\"$\",\"$Lc\",null,{\"postDates\":[\"2025-03-20\",\"2025-02-06\",\"2024-12-13\",\"2024-10-19\",\"2024-10-15\",\"2024-10-07\"],\"className\":\"bg-teal-700 border-teal-950\"}]}],[\"$\",\"div\",null,{\"className\":\"flex overflow-y-auto w-full\",\"children\":[\"$\",\"$Ld\",null,{\"postSummaries\":[{\"frontmatter\":{\"title\":\"React.FC는 사용이 권장되지 않습니다\",\"created_at\":\"2025-03-20\",\"updated_at\":\"2025-03-20\",\"tags\":[\"react\"]},\"preview\":\"React.FC는 React18 부터 사용 방식이 변경되었습니다\\n\\nReact.FC는 React 18부터 사용 방식이 변경되었습니다.\\n\\nFunctoinComponent는 React17 버전 이하에서 함수형 컴포넌트를 정의할 때 사용되었으나 암묵적으로 children을 props 로 포함한다는 문제점을 가지고 있었습니다. React 18 버전에서 children props의 암묵적 포함 문제가 해결되었으나 필요한 경우 명시적으로 children을 props로 포함하는 방식이 더 낫기 때문에 React.FC의 사용은 권장되지 않습니다.\\n\\nReact18과 React17의 React.FC 정의를 살펴보면 아래와 같습니다.\\n\\n\\n// React18\\n\\ntype FC\u003cP = {}\u003e = FunctionComponent\u003cP\u003e;\\n\\ninterface FunctionComponent\u003cP = {}\u003e {\\n\\t\\t(\\n\\t\\t\\t\\tprops: P,\\n\\t\\t\\t\\tdeprecatedLegacyContext?: any,\\n\\t\\t): ReactNode;\\n\\t\\tpropTypes?: WeakValidationMap\u003cP\u003e | undefined;\\n\\t\\tcontextTypes?: ValidationMap\u003cany\u003e | undefined;\\n\\t\\tdefaultProps?: Partial\u003cP\u003e | undefined;\\n\\t\\tdisplayName?: string | undefined;\\n}\\n\\n\\n\\n// React17\\n\\n\",\"fileNameWithoutExtension\":\"React.FC\"},{\"frontmatter\":{\"title\":\"URI, URL 그리고  URN\",\"created_at\":\"2025-02-06\",\"updated_at\":\"2025-02-24\",\"tags\":[\"URI\",\"URL\",\"URN\"]},\"preview\":\"- URI(Uniform Resource Identifier)\\n  : 자원을 고유하게 식별하는 모든 문자열로 URL과 URN을 포함하는 개념\\n- URL (Uniform Resource Locator)\\n  : 자원의 위치(경로)를 나타내는 URI\\n- URN(Uniform Resource Name)\\n  : 자원의 이름을 나타내는 URI\\n\\n\\n URI(Uniform Resource Identifier)\\n\\nURI는 자원을 식별하기 위한 모든 문자열을 의미합니다.\\n자원의 위치(URL) 또는 이름(URN)을 포함할 수 있으며, 자원을 고유하게 식별할 수 있는 기준입니다.\\nURI는 URL과 URN을 포함하는 상위 개념입니다.\\n\\n\\n\u003c예시\u003e\\n- URL: https://www.example.com/page (경로를 통해 자원을 식별)\\n- URN: urn:isbn:0451450523 (이름을 통해 자원을 식별)\\n\\n\\n\\n\\n URL(Uniform Resource Loactor)\\n\\nURL은 자원의 위치(경로)를 포함한 URI의 한 형태입니다.\\n자원에 접근하는 방법인 프로토콜(예: https, ftp)과 자원의 경로를 명시하여, 자원이 어디에 있고 어떻게 접근할 수 있는지를 알려줍니다.\\n브라우저의 주소창에서 입력하여 자원에 접근할 때 사용됩니다.\\n\\n**URL의 구성 요소**\\n- 프로토콜(protocol): https://\\n- 도메인(domain): www.exam\",\"fileNameWithoutExtension\":\"uri_url_and_urn\"},{\"frontmatter\":{\"title\":\"Event Bubbling, Capturing, preventDefault  그리고 stopPropagation\",\"created_at\":\"2024-12-13\",\"updated_at\":\"2024-12-13\",\"tags\":[\"preventDeafult\",\"stopPropagation\",\"bubbling\",\"capturing\"]},\"preview\":\"bubbling과 capturing\\n\\n버블링(bubbling)과 캡쳐링(capturing)은 DOM에서 이벤트가 발생할 때 이벤트가 전파되는 방식에 대한 개념입니다.\\n\\n버블링(bubbling)은 이벤트가 발생한 요소에서 시작하여 상위 요소들로 전파되는 것으로 이벤트 전파의 기본 동작입니다.\\n캡쳐링(capturing)은 버블링과 반대로, 이벤트가 상위 요소에서 시작하여 하위 요소로 전파되는 것으로 기본적으로 비활성화되어 있습니다.\\n\\n\\n bubbling\\n\\n버블링에서 이벤트는 DOM 트리를 따라 위로 올라가면서 부모 요소들에 전파됩니다. 최종적으로는 최상위 요소(window)까지 전파됩니다.\\n\\n\\n\u003cbody\u003e\\n\\t\u003cdiv id=\\\"parent\\\"\u003e\\n\\t  \u003cbutton id=\\\"child\\\"\u003eClick me\u003c/button\u003e\\n\\t\u003c/div\u003e\\n\\t\u003cdiv id=\\\"sibling-of-parent\\\"\u003e\u003c/div\u003e\\n\u003c/body\u003e\\n\\n\\n\\ndocument.getElementById(\\\"child\\\").addEventListener(\\\"click\\\", function() {\\n  console.log(\\\"child clicked!\\\");\\n});\\ndocument.getElementById(\\\"parent\\\").addEventListener(\\\"click\\\", function() {\\n  console.log(\\\"parent clicked!\\\");\\n});\\ndocument.getElementById(\\\"\",\"fileNameWithoutExtension\":\"eventBubbling_capturing_preventDefault_and_stopPropagation\"},{\"frontmatter\":{\"title\":\"인터페이스(interface)와 타입 별칭(type alias)\",\"created_at\":\"2024-10-19\",\"updated_at\":\"2024-10-19\",\"tags\":[\"interface\",\"type_alias\"]},\"preview\":\"타입스크립트에서 인터페이스와 타입 별칭은 객체의 구조를 정의하는 데 사용됩니다.\\n\\n 인터페이스(interface)\\n\\n인터페이스는 클래스와 같은 구조체의 형식을 정의하는 데 많이 사용되며 다른 인터페이스로부터 상속받을 수 있습니다. interface 키워드를 사용하여 정의합니다.\\n\\n\\n// interface example\\n\\ninterface Person {\\n  name: string;\\n  age: number;\\n}\\n\\ninterface Employee extends Person {\\n    employeeId: number;\\n}\\n\\n\\n여러 개의 인터페이스를 병합할 수도 있습니다. 동일한 이름의 인터페이스를 여러 번 정의하면 TypeScript는 이를 자동으로 병합하여 하나의 인터페이스로 만들어줍니다.\\n\\n\\ninterface Person {\\n  name: string;\\n}\\n\\ninterface Person {\\n  age: number;\\n}\\n\\ninterface Person {\\n  address: string;\\n}\\n\\n// 병합된 Person 인터페이스\\ninterface Person {\\n  name: string;\\n  age: number;\\n  address: string;\\n}\\n\\n\\n\\n 타입 별칭(type alias)\\n\\n특정 타입에 대해 별칭을 만드는 방법으로 type 키워드를 사용하여 정의합니다.\\n기본 타입, 유니언 타입, 튜플 타입 등 다양한 타입을 \",\"fileNameWithoutExtension\":\"interface_and_type_alias\"},{\"frontmatter\":{\"title\":\"얕은 복사(shallow copy)와 깊은 복사(deep copy)\",\"created_at\":\"2024-10-15\",\"updated_at\":\"2024-10-15\",\"tags\":[\"shallow_copy\",\"deep_copy\",\"primitive_type\",\"reference_type\",\"value_type\"]},\"preview\":\"얕은 복사(shallow copy): copy by value + copy by reference\\n\\n얕은 복사는 iterable(객체, 배열, 등)의 최상위 요소들만 복사하고, 하위 요소는 원본과 동일한 참조(reference)를 공유하는 방식입니다.\\n\\n얕은 복사는 하위 요소에 대해 참조(reference)만을 복사하기 때문에 **더 빠르게 동작**하고 **더 적은 메모리**를 사용합니다. 하지만, 참조의 공유는 원본 요소나 복사된 요소의 변경이 예상치 못한 결과로 이어질 수 있기 때문에 사용에 주의가 필요합니다.\\n\\n 얕은 복사의 예\\n\\n- Object.assign()\\n- Spread Operator(...)\\n- Array.prototype.slice()\\n- Array.prototype.concat()\\n\\n\\n\\n 깊은 복사(deep copy): copy by value\\n\\n깊은 복사는 독립적인 새로운 객체를 만드는 방식입니다. 원본 객체에서 값 만을 복사하므로 복사된 객체를 수정해도 원본 객체에 영향을 미치지 않습니다. \\n\\n\\n 깊은 복사의 예\\n\\n- JSON.parse(JSON.stringify())\\n\\n\\n\\n 예: Todo 객체로 알아보는 얕은 복사와 깊은 복사\\n\\n\\n예시에 사용할 중첩 객체(nested object) todo\\n\\ninterface Todo {\\n  id: number;\\n  task: string;\\n  category: string;\",\"fileNameWithoutExtension\":\"shallow_copy_and_deep_copy\"},{\"frontmatter\":{\"title\":\"정규 표현식(regular expression)\",\"created_at\":\"2024-10-07\",\"updated_at\":\"2024-10-22\",\"tags\":[\"regular_expression\"]},\"preview\":\"정규 표현식\\n\\n정규 표현식이란 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어(특정한 법칙들에 따라 적절하게 구성된 문자열들의 집합)입니다.\\n\\n replace 함수\\n\\n\\nreplace(pattern, replacement)\\n\\n\\n- replace 함수의 첫 번째 인자는 문자열 또는 Symbol.replace 메서드를 가진 객체(예: 정규표현식)입니다.\\n- 두 번째 인자는 문자열 또는 함수입니다.\\n\\n\\n 정규 표현식 예시 모음\\n\\n 예시1: ![[...]] 패턴을 찾기 위한 정규 표현식\\n\\n\\n/!\\\\[\\\\[.*?\\\\]\\\\]/g\\n\\n\\n /.../g\\n- /는 정규 표현식의 시작과 끝을 나타냅니다.\\n- g는 전역 플래그(Global flag)로 텍스트 전체에서 모든 일치 항목을 찾도록 합니다.\\n\\n !\\\\[\\\\[ 와 \\\\]\\\\]\\n- 이스케이프 문자('\\\\')를 포함한 ![[...]]\\n\\n .*?\\n- .는 임의의 단일 문자를 의미합니다.\\n- *는 0번 이상의 반복을 의미합니다.\\n- ?는 Non-greedy 모드를 의미합니다. 기본적으로 *는 가능한 많은 문자를 포함하려 하지만 ?가 있으면 가능한 적은 문자를 포함하게 됩니다. 즉, 첫번째 [[와 가장 가까운 ]]를 찾습니다.\\n\\n\\n\\n 예시2: 케밥 케이스 문자열을 카멜 케이스 문자열로 변환하기\\n\\n\\nconst kebabStr = \\\"hello-world\\\";\\nconst camelStr = kebabStr.rep\",\"fileNameWithoutExtension\":\"regular_expression\"}],\"tagsClassName\":\"bg-emerald-500\"}]}]]}]\n"])</script></body></html>